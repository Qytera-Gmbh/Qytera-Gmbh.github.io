{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>On the following pages you can find instructions for the product QTAF.</p>"},{"location":"#content","title":"Content","text":""},{"location":"#basics-of-test-automation","title":"Basics of Test Automation","text":"<ul> <li>The Page Object Model</li> <li>How to create a new project with IntelliJ</li> <li>How to create a new project with VSCode</li> </ul>"},{"location":"#first-steps-with-qtaf","title":"First steps with QTAF","text":"<ul> <li>How to create your first QTAF project</li> <li>Use Data Providers in your test scenarios</li> <li>Exploring the HTML report</li> <li>How to run your tests against different browsers using QTAF<ul> <li>Connect QTAF to a remote driver</li> <li>Running test cases on the Saucelabs platform</li> <li>Write your own drivers</li> </ul> </li> </ul>"},{"location":"#qtaf-plugins","title":"QTAF Plugins","text":"<ul> <li>Xray Plugin</li> <li>Allure Plugin</li> </ul>"},{"location":"#qtaf-and-cucumber","title":"QTAF and Cucumber","text":"<ul> <li>Create a QTAF Cucumber project</li> </ul>"},{"location":"#dive-deeper-into-qtaf","title":"Dive deeper into QTAF","text":"<ul> <li>How the QTAF logging system works</li> <li>Setup QTAF Locally</li> <li>Which Annotations does QTAF provide?</li> </ul> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/Page_Object_Model/","title":"Page Object Model","text":"<p>The Page Object Model is a software design pattern that describes interfaces for software-controlled manipulation of an element of a graphical user interface. The basic idea of the Page Object Model is to describe and control elements of a GUI through a parameterisable code base. The page object model is often used in the software-based automation of software applications with a graphical user interface.</p> <p>There are two basic ways to select elements of a graphical user interface: First, each element can be assigned a unique ID. On the other hand, there is the possibility to select elements by means of a query language. A page object consists of a set of selectors that identify one or more elements of a GUI by means of an ID or a query language. In the context of web applications, GUI elements are mainly identified by unique IDs, CSS or HTML attributes. Furthermore, methods are defined in a page object that can perform a manipulation on one or more elements of the web application or read their attributes. The attributes of a GUI element are, for example, information about the graphic representation of the element (height, width, colours, etc.), its position on the display device and its relationship to other elements of the GUI.</p>"},{"location":"sections/Page_Object_Model/#example-of-page-objects","title":"Example of page objects","text":"<p>The following HTML code is an example of a page object for a website. The page object shown consists of four basic elements: An image, a headline, a text and a button.</p> <p></p> <p>This is the corresponding HTML source code of the shown UI element:</p> <pre><code>&lt;div&gt;\n&lt;img\nsrc=\"https://www.qytera.de/sites/default/files/startseite-2020/qytera-testmanagement-300-169.jpg\" alt=\"\" class=\"startseite-saeulen-logo\" /&gt;\n&lt;h3&gt;Continuous Testing&lt;/h3&gt;\n&lt;p&gt;Wir verhelfen Ihnen zu kontinuierlichen und schnellen Softwarelieferungen in hoher Qualit\u00e4t.&lt;/p&gt;\n&lt;form action=\"https://www.qytera.de/testing-solutions/continuous-testing\" method=\"get\"&gt;\n&lt;button class=\"button-red consulting-blog-verlinkung-button\"&gt;Mehr erfahren&lt;/button&gt;\n&lt;/form&gt;\n&lt;/div&gt;\n</code></pre> <p>In test automation, a class is now created in which methods for interacting with the elements of the page object are defined. Useful methods for interacting with the page object shown could be reading the headline and the text as well as clicking the button.</p> <p>The following is an example of the definition of a page object using the Java programming language. The root node of the page object is passed to the class in the constructor. Subsequently, references to the UI elements (image, heading, text and button) are stored in the class attributes. Furthermore, methods for interacting with the page object are defined in the class, such as reading out the texts of the elements or other attributes such as the URL of the image.</p> <pre><code>public class CardPageObject {\nHTMLImageElement image;\nHTMLElement headline;\nHTMLParagraphElement paragraph;\nHTMLButtonElement button;\nCardPageObject(WebElement rootElement) {\nimage = (HTMLImageElement) rootElement.findElement(By.cssSelector(\"img.startseite-saeulen-logo\"));\nheadline = (HTMLElement) rootElement.findElement(By.cssSelector(\"h3\"));\nparagraph = (HTMLParagraphElement) rootElement.findElement(By.cssSelector(\"p\"));\nbutton = (HTMLButtonElement) rootElement.findElement(By.cssSelector(\"button.button-red\"));\n}\nString getImageSource() {\nreturn image.getAttribute(\"src\");\n}\nString getHeadlineText() {\nreturn headline.getAttribute(\"innerText\");\n}\nString getParagraphText() {\nreturn paragraph.getAttribute(\"innerText\");\n}\nvoid clickButton() {\n((WebElement) button).click();\n}\n}\n</code></pre> <p>On the website examined, UI elements with a similar structure to the one shown can be found. From the point of view of test automation, it makes no sense to abstract each of these objects with its own page object class. Instead, it makes more sense to create a common class for these page objects and to pass parameters to this class that can be used to react to deviations between the individual page objects.</p> <p></p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/cucumber/New_Cucumber_Project/","title":"Create a Cucumber Project with QTAF","text":"<p>This article describes how to set up a QTAF Cucumber project. It is assumed that you have already set up a Maven project using IntelliJ and have included QTAF as a dependency. How this can be done is described in the following article: QTAF - Project Creation. Also you can use our QTAF with Cucumber example project to try it out.</p>"},{"location":"sections/cucumber/New_Cucumber_Project/#create-folder-and-package-structure","title":"Create folder and package structure","text":"<p>The Java code of the Maven project is stored in the subfolder <code>src/main/java</code>, the resources (all other required files) in the subfolder <code>src/main/resources</code>.</p> <p>Within the Java directory we create the package <code>org.acme</code>, because in this example we are creating a project for the fictitious company Acme GmbH. Furthermore, we create the folder <code>features</code> in the <code>resources</code> directory, which will later contain our feature files.</p>"},{"location":"sections/cucumber/New_Cucumber_Project/#creating-test-cases","title":"Creating test cases","text":"<p>To create test cases using Qtaf with Cucumber, we first need to create a so-called test runner. This test runner is a class that provides information about the location of the Cucumber feature files and the step definitions by means of an annotation.</p> <p>In the following example we assume that our source code is organised in the package <code>org.acme</code>. We create a new class in this package called <code>TestRunner</code>. This class must have the following properties:</p> <ol> <li>The class will have the annotation <code>@CucumberOptions</code>. This annotation provides information on where to find the feature files <code>(features = {\"...\"})</code>, where to find the corresponding step definitions <code>(glue = {\"...\"})</code>, which tag (not) to run <code>(tags = \"...\")</code> and which Cucumber plugin to use to create the reports <code>(plugin = {\"...\"})</code>.</li> <li>The <code>TestRunner</code> class must inherit from the CucumberQtafTestContext class.</li> <li>The <code>TestRunner</code> class must contain a method that is annotated with the <code>@DataProvider</code> annotation of the TestNG framework and returns a list of scenarios, which is done by calling <code>super.scenarios()</code>.</li> </ol> <p>The following code shows a sample implementation of this class:</p> <pre><code>package org.acme;\nimport de.qytera.qtaf.cucumber.context.QtafTestNGCucumberContext;\nimport io.cucumber.testng.CucumberOptions;\nimport org.testng.annotations.DataProvider;\n/**\n * Main class to execute Cucumber Tests\n */\n@CucumberOptions(\nfeatures = {\"src/main/resources/features\"},\nglue = {\"org.acme.stepdefs\"},\ntags = \"\",\nplugin = {\"pretty\"}\n)\npublic class TestRunner extends QtafTestNGCucumberContext {\n@Override\n@DataProvider(parallel = true)\npublic Object[][] scenarios() {\nreturn super.scenarios();\n}\n}\n</code></pre>"},{"location":"sections/cucumber/New_Cucumber_Project/#creating-a-scenario-listener","title":"Creating a scenario listener","text":"<p>In order for QTAF to be able to create log files for the executed test cases, you have to create another class in the folder you specified in the <code>@CucumberOptions</code> annotation in the <code>glue</code> attribute. In this case, this would be the folder <code>org.acme.stepdefs</code>.</p> <p>In this folder, create a class called <code>TestListener</code> that inherits from the QTAF framework class <code>QtafCucumberHooks</code> and add the following methods to it:</p> <pre><code>package org.acme.stefdefs;\nimport de.qytera.qtaf.cucumber.listener.QtafCucumberHooks;\nimport io.cucumber.java.*;\n/**\n * This class listens to cucumber hooks and produces logs\n */\npublic class TestListener extends QtafCucumberHooks {\n@Before\npublic void onBeforeScenario(Scenario scenario) {\nbeforeScenario(scenario);\n}\n@After\npublic void onAfterScenario(Scenario scenario) {\nafterScenario(scenario);\n}\n@BeforeStep\npublic void onBeforeStep(Scenario scenario) {\nbeforeStep(scenario);\n}\n@AfterStep\npublic void onAfterStep(Scenario scenario) {\nafterStep(scenario);\n}\n}\n</code></pre> <p>Cucumber will automatically recognise this class as a listener class through the annotations <code>@Before</code>, <code>@BeforeStep</code>, <code>@After</code> and <code>@AfterStep</code>. Within this methods, we let the QTAF framework perform the further steps for logging by calling these methods.</p>"},{"location":"sections/cucumber/New_Cucumber_Project/#creating-feature-files","title":"Creating feature files","text":"<p>In the <code>TestRunner</code> class we have specified that the feature files are to be found in the <code>src/main/resources/features</code> directory relative to the root directory of our project. In this folder we now place our first feature file with the name <code>GoogleSearch</code>.feature. The name of the file can be freely chosen. As long as the file ends with <code>.feature</code> and is located in the directory that we specified with the annotation <code>@CucumberOptions</code>, Cucumber is able to find this file and interpret it as a test case.</p> <p>Now we write the following content into our feature file:</p> <pre><code># Test the Qytera search function\nFeature: Qytera Search\n  # This step will run before each scenario\nBackground: The browser will be launched\n    Given Launch the browser\n  # Test case 1\n@TestName:QTAF-1\nScenario: Search for Cucumber in Qytera\n    Then Enter \"Cucumber\" in the search text box\nAnd Select the first result\n</code></pre>"},{"location":"sections/cucumber/New_Cucumber_Project/#creating-step-definitions","title":"Creating Step Definitions","text":"<p>Step definitions are Java classes that contain the code to be executed when a step is called in a feature file. For example, if we have defined the step <code>Then Enter \"Cucumber\" in the search text box</code> in our feature file, Cucumber does not yet know what to do when it sees this statement. To tell Cucumber this, we create a new class called <code>StepDefs</code> in the package <code>org.acme.stepdefs</code>. We have previously defined the package name via the annotation <code>@CucumberOptions</code>. Furthermore, classes that contain step definitions must inherit from the class <code>QtafTestNGContext</code>.</p> <p>In the following example, all steps are defined that are called in our feature file. Among other things, this class provides the attribute <code>driver</code>, which provides an instance of a web driver.</p> <pre><code>package org.acme.stepdefs;\nimport de.qytera.qtaf.core.context.QtafTestContext;\nimport io.cucumber.java.en.Given;\nimport io.cucumber.java.en.Then;\nimport io.cucumber.java.en.When;\nimport org.openqa.selenium.WebDriver;\nimport org.testng.Assert;\npublic class StepDef extends QtafTestContext {\n@Given(\"Launch the browser\")\npublic void launchTheBrowser() {\ndriver.get(\"https://www.qytera.de\");\n}\n@When(\"Hit Qytera on your browser\")\npublic void hitQytera() {\nAssert.assertEquals(3, 3);\n}\n@Then(\"Enter {string} in the search text box.\")\npublic void enterStringInSearchBox(String string) {\nSystem.out.println(\"Search box: \" + string);\n}\n@Then(\"Select the first result.\")\npublic void selectTheFirstResult() {\nAssert.assertEquals(1, 1);\n}\n}\n</code></pre>"},{"location":"sections/cucumber/New_Cucumber_Project/#run-program","title":"Run program","text":"<p>Now the project is ready so that we can run it for the first time. To do this, we click on an icon with a green file to the left of the name of the main class in IntelliJ. A dialogue then opens where we click on Run <code>CucumberRunner</code>. This first run allows QTAF to create further required directories and files on its own.</p> <p></p> <p>A browser will open for a short time. However, since we have not yet created any test cases, it will close again after a short time. Furthermore, a configuration file called <code>qtaf.json</code> is created in the resource directory, as well as the folder <code>logs</code>, in which you can already see log files for the test run we have just carried out.</p> <p>The project is now ready for the creation of test cases.</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/dive/Overview_Annotations/","title":"QTAF Annotations","text":"<p>In this article we show you which annotations QTAF provides.</p>"},{"location":"sections/dive/Overview_Annotations/#test-cases","title":"Test cases","text":""},{"location":"sections/dive/Overview_Annotations/#testfeature","title":"@TestFeature","text":"<p>The annotation <code>@TestFeature</code> is used to annotate classes that contain test cases. <code>@TestFeature</code> expects the attributes <code>name</code> and <code>description</code>. This annotation is used to describe the test cases defined in the class.</p> <pre><code>import de.qytera.qtaf.core.config.annotations.TestFeature;\nimport org.testng.annotations.Test;\n@TestFeature(\nname = \"Test Feature One\",\ndescription = \"This is the first test feature\"\n)\npublic class TestFeatureOne extends TestContext {\n@Test(testName = \"T1\", description = \"First Test Case\")\npublic void testOne() {\n// ...\n}\n}\n</code></pre>"},{"location":"sections/dive/Overview_Annotations/#test","title":"@Test","text":"<p>The annotation <code>@Test</code> comes from the TestNG framework and can be used as usual to annotate methods that contain test cases. Several test cases can be defined in a class. The test cases that are defined within a class should have a similar context, otherwise the test cases should be divided among several classes.</p>"},{"location":"sections/dive/Overview_Annotations/#page-objects","title":"Page Objects","text":""},{"location":"sections/dive/Overview_Annotations/#step","title":"@Step","text":"<p>The annotation <code>@Step</code> comes from the QTAF framework and is used for methods that represent a test step. This annotation has the attributes <code>name</code> and <code>description</code>, with which the test step can be given a name and a description. These attributes are used when generating log files and reports.</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/dive/Overview_Logging/","title":"QTAF Logging","text":"<p>This article explains how the log files of QTAF are structured, how they are represented internally in the QTAF framework and how new log entries are created at runtime.</p>"},{"location":"sections/dive/Overview_Logging/#structure-of-the-log-files","title":"Structure of the log files","text":"<p>QTAF assumes a hierarchical structure of test cases and bases the naming of the test hierarchy on the test framework Cucumber. At the top is the test suite, which contains test features. In the QTAF framework, all test classes annotated with <code>@TestFeature</code> form such a test suite.</p> <p>A test feature is a list of test cases (scenarios) that perform similar tests, for example testing the behaviour of a button on a web page. In the QTAF framework, scenarios are implemented using methods within TestFeature classes. These methods are provided with the annotation <code>@Test</code> of the TestNG framework.</p> <p>A scenario, in turn, can be subdivided into test steps. Steps are implemented in QTAF by means of methods, which are provided with the annotation <code>@Step</code>. These methods are usually stored in separate page object classes so that they can be used in several scenarios.</p> <p></p> <p>QTAF log files are also hierarchically structured and represent the structure described above. The top level is the so-called <code>SuiteLogCollection</code>. This is a data object that contains the data about all tested features. Within this object there is a list of <code>FeatureLog</code> objects, which in turn contain a list of <code>ScenarioLog</code> objects. Finally, these contain a list of <code>StepLog</code> objects.</p> <p></p>"},{"location":"sections/dive/Overview_Logging/#the-class-testsuitelogcollection","title":"The class TestSuiteLogCollection","text":"<p>To start logging, an instance of the class <code>TestSuiteLogCollection</code> must first be created. This is done by QTAF at the beginning of the test execution, you as a user do not have to take care of this process. This class follows the singleton design pattern, that means that there is exactly one instance of this class at runtime. QTAF therefore assumes that exactly one test suite is executed within a single process. You can get the instance of the class by calling <code>QtafFactory.getTestSuiteLogCollection()</code> anywhere in your code. Inside the <code>TestSuiteLogCollection</code> class, general information about the test suite is collected, such as the name of the test suite and the start and end time of testing, the name of the driver used, and the duration of the testing process. Exactly one JSON logfile is created from an instance of TestSuiteLogCollection after all test scenarios have been run. This log file contains the information shown.</p> <pre><code>{\n\"suiteInfo\": {\n\"name\": \"MyTestSuite\",\n\"outputDir\": \"C:\\\\Users\\\\myuser\\\\MyTestProject\"\n},\n\"driverName\": \"chrome\",\n\"start\": \"Feb 26, 2021, 1:19:58 PM\",\n\"end\": \"Feb 26, 2021, 1:21:21 PM\",\n\"duration\": 83393,\n\"testFeatureLogCollection\": [\n// Test Feature Logs ...\n]\n}\n</code></pre>"},{"location":"sections/dive/Overview_Logging/#the-testfeaturelogcollection-class","title":"The TestFeatureLogCollection class","text":"<p>The next hierarchy level below the test suite are the test features. This is a grouping of test cases, which in QTAF are called test scenarios. Test scenarios are represented by a class in TestNG. In Cucumber, test scenarios are organised in feature files. The test suite is then the set of all test classes / feature files. For each class / feature file, an instance of the class <code>TestFeatureLogCollection</code> is created and given a unique ID. In Java-based frameworks such as TestNG / JUnit, this ID corresponds to the class name in which the test scenario was defined, in Cucumber it corresponds to the name of the feature file. If you try to create a new instance of a <code>TestFeatureLogCollection</code> with an existing ID, the existing instance is returned and no new instance is created. Within the log file, the data about the recorded test features is stored in the attribute <code>testFeatureLogCollection</code>. This data includes the unique ID of the feature, its name and description, and a list of information about all test scenarios of the feature.</p> <pre><code>// ...\n\"testCaseLogCollection\": [\n{\n\"classId\": \"tests.DoGoogleSearch\",\n\"testCaseAnnotation\": {\n\"name\": \"DoGoogleSearch\",\n\"description\": \"Perform a search for text \\u0027Hello World\\u0027\"\n},\n\"testSzenarioLogCollection\": [\n// Test Szenario Logs ...\n]\n// ...\n</code></pre>"},{"location":"sections/dive/Overview_Logging/#the-class-testscenariologcollection","title":"The class TestScenarioLogCollection","text":"<p>The class <code>TestScenarioLogCollection</code> is the next hierarchical class below <code>TestFeaturelogCollection</code>.  For each executed test case, an instance of this class is created and the information about the executed test case is stored in it. Within TestNG / JUnit, test scenarios are represented by class methods annotated with <code>@Test</code>. QTAF records information such as the start and end time of a test case, the name and description of the test case and its status (passed / failed / not executed).</p> <p>Test scenarios are also assigned a unique ID, which in TestNG / JUnit is composed of the class name plus the method name and in Cucumber by the name of the feature file plus the scenario name. This naming is always unique and enables the traceability of the test results to the test cases.</p> <p>Within the log file, the results are stored in the attribute testSzenarioLogCollection of the features and look like this:</p> <pre><code>// ...\n\"testLogCollection\": [\n{\n\"uniqueId\": 224219987,\n\"methodId\": \"tests.DoGoogleSearch.TestCaseGoogleSearch\",\n\"testId\": \"QTAF-1\",\n\"description\": \"Type \\u0027Hello World\\u0027 and click search button\",\n\"start\": \"Feb 26, 2021, 1:19:58 PM\",\n\"end\": \"Feb 26, 2021, 1:20:10 PM\",\n\"duration\": 11992,\n\"groups\": [],\n\"groupDependencies\": [],\n\"methodDependencies\": [],\n\"testParameters\": [],\n\"status\": \"FAILURE\",\n\"logMessages\": [\n// Step Logs\n]\n},\n// ... Weitere Szenario Logs\n]\n// ...\n</code></pre> <p>In the following example, the relationship between features and scenarios is explained using a TestNG example. The class itself represents a feature, the three methods it contains are the test scenarios. The set of all test classes forms the test-suite.</p> <pre><code>public class MyTestFeature {\n@Test()\npublic void testScenario1() {\n// ...\n}\n@Test()\npublic void testScenario2() {\n// ...\n}\n@Test()\npublic void testScenario3() {\n// ...\n}\n}\n</code></pre>"},{"location":"sections/dive/Overview_Logging/#the-logmessage-class","title":"The LogMessage class","text":"<p>Now the lowest level of the log hierarchy comes into play. Test cases, which are methods themselves, can be broken down into further methods. This enables the reuse of code and increases its readability. Each of these methods is called a \"step\" in QTAF. Accordingly, the log messages documenting the call of these methods are called \"StepLogs\" and are represented by the class <code>StepLogMessage</code>. Here, however, only method calls are recorded where the method itself is provided with the annotation <code>@Step</code> of the Qtaf framework. This gives you full control over which methods should be recorded and which should not. Each <code>StepLogMessage</code> instance contains information about the name of the called method, the status (passed, failed, not executed) and the start and end time of the execution of the method.</p> <p>Within the logfile, the information about the executed step methods is stored within the keyword logMessages of the test scenario logs. A StepLog entry in the logfile looks like this:</p> <pre><code>// ...\n\"logMessages\": [\n{\n\"type\": \"STEP_LOG\",\n\"methodName\": \"pageobjects.googlePage.GoogleFunctions.goToGoogleHome\",\n\"step\": {\n\"name\": \"Go to Google home page\",\n\"description\": \"Navigate to the Google home page\"\n},\n\"status\": \"PASSED\",\n\"start\": \"Feb 26, 2021, 1:19:58 PM\",\n\"end\": \"Feb 26, 2021, 1:20:00 PM\",\n\"duration\": 1761,\n\"stepParameters\": [],\n\"level\": \"INFO\",\n\"message\": \"Step Go to Google home pageexecuted\"\n},\n// ...\n]\n// ...\n</code></pre>"},{"location":"sections/dive/Overview_Logging/#creation-of-log-objects-at-runtime","title":"Creation of log objects at runtime","text":"<p>QTAF provides its own listener class for the test frameworks TestNG and Cucumber, with which it reacts to the events triggered by these frameworks. Since the data that TestNG and Cucumber transmit by means of these events differ greatly in their structure, QTAF implements a translation layer (transformer) for these events and translates the data they contain into its own data structure. This makes the event subscribers independent of the test framework used.</p> <p>After QTAF has translated the events of the test framework used into its own data structure, it informs its subscribers about this. They can now process the triggered events and the transmitted data. This event system can also be used to develop your own plug-ins.</p> <p>The following diagram shows the process from the creation to the processing of the event.</p> <p></p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/dive/Setup_QTAF_Locally/","title":"Local Setup of QTAF","text":"<p>In this article we describe how QTAF can downloaded and installed locally. This should be done if you want to use beta verisons of QTAF, develop own plugins or add modifications of the code.</p> <p>We assume that you have already cloned the QTAF source code from the GitHub repository to your machine. Otherwise navigate to a directory of your choice and execute the following command: </p> <pre><code>$ git clone https://github.com/Qytera-Gmbh/QTAF\n</code></pre> <p>You can then start editing the QTAF source code.</p> <p>If you would like to try out your changes locally first, you can proceed as follows.</p> <ol> <li> <p>Set a new version number for QTAF. This version number should contain the addition \"LOCAL\" to make it clear that it is only a locally developed version that is not to be deployed to the central repository. For example, you could assign the version number \"LOCAL-2022-11-14-001\". Since the QTAF project is divided into several modules and each of these modules has its own POM file, it can be tedious and error-prone to update the version number of each POM file. Instead, you can run the command <code>mvn versions:set \"-DnewVersion=&lt;version&gt;\"</code> to update the version numbers of all modules.</p> </li> <li> <p>Then run the command <code>mvn clean install</code> to install the current version of QTAF locally. This may take some time as all test cases will also be executed. If you want to skip the test cases you can append the option <code>-DskipTests=true</code> to the command.</p> </li> <li> <p>After the installation has been completed, you can integrate the new, local QTAF version in other projects via the POM file.</p> </li> </ol> <pre><code>&lt;dependency&gt;\n&lt;groupId&gt;de.qytera&lt;/groupId&gt;\n&lt;artifactId&gt;qtaf-core&lt;/artifactId&gt;\n&lt;version&gt;LOCAL-2022-11-14-001&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>For example, use demo projects such as the SuiteCRM demo project to test the changes to the QTAF framework and their effects.</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/faq/FAQ/","title":"FAQ","text":"When running <code>mvn:exec</code>, I get an error message <code>java.lang.ClassNotFoundException: some.package.TestRunner</code>. Make sure to run <code>mvn install -DskipTests</code> first."},{"location":"sections/plugins/Allure_Plugin/","title":"Allure Plugin","text":"<p>This article is about installing the tool Allure, which you can use to generate test reports.</p> <p>First we need to take care of the installation of Allure. Go to the Central Repository page: Allure CLI and download the file called <code>allure-commandline-*.zip</code>, replacing <code>*</code> with the latest version. Unzip it to a directory of your choice. Inside the directory where you saved Allure you will find the folder <code>bin</code>. Add this to the environment variable <code>PATH</code>. Then open a terminal and enter the command <code>allure</code>. You should see a list of possible commands for the Allure CLI.</p>"},{"location":"sections/plugins/Allure_Plugin/#alternative-installation-possibility-with-scoop","title":"Alternative installation possibility with Scoop","text":"<p>Scoop is a command line installation programme for Windows. With Scoop you can install programs and plugins for your terminal.</p> <ol> <li>Open PowerShell. You can do this by searching for PowerShell in the Start menu.</li> <li>Type the following in PowerShell: <code>iwr -useb get.scoop.sh | iex</code></li> <li>Press the Enter key. PowerShell will now install Scoop.</li> </ol> <p>If you get an error message regarding ExecutionPolicy after entering the command line, enter the following command in PowerShell:</p> <pre><code>Set-ExecutionPolicy RemoteSigned -scope CurrentUser.\n</code></pre> <p>This will change the <code>ExecutionPolicy</code> for your account to remote signed and you can install Scoop. After installing Scoop, you can access Scoop Help in PowerShell or Command Prompt to get a list of Scoop commands.</p> <p>After you have installed Scoop, open PowerShell and enter the following command:</p> <pre><code>scoop install allure\n</code></pre> <p>You can verify that Allure is installed correctly by opening a terminal and typing <code>allure</code>. You should see a list of possible commands for the Allure CLI.</p>"},{"location":"sections/plugins/Allure_Plugin/#the-qtaf-allure-plugin","title":"The QTAF Allure Plugin","text":"<p>In addition to <code>qtaf-core</code>, first integrate the dependency <code>qtaf-allure-plugin</code> into your project: Make sure that you use the current version numbers of these modules. You can find them at the Maven Repository</p> <pre><code>&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;de.qytera&lt;/groupId&gt;\n&lt;artifactId&gt;qtaf-core&lt;/artifactId&gt;\n&lt;version&gt;0.0.3&lt;/version&gt;\n&lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;de.qytera&lt;/groupId&gt;\n&lt;artifactId&gt;qtaf-allure-plugin&lt;/artifactId&gt;\n&lt;version&gt;0.0.3&lt;/version&gt;\n&lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>Check the Maven Central repository for the current version of the plugin.</p> <p>This completes the installation of the Allure plugin. In the <code>configuration.json</code> file, you can now add the following options for taking screenshots, which will then be included in the Allure report:</p> <pre><code>\"driver\":{\n\"name\": \"chrome\",\n\"screenshots\": {\n\"beforeScenario\": true,\n\"afterScenario\": true,\n\"beforeStep\": true,\n\"afterStep\": true\n}\n}\n</code></pre> <p>You can then run your test cases as usual. After the test cases have been executed, the QTAF Allure plugin automatically creates the folder <code>allure-results</code> in the root directory of your project. This is where the data for the Allure report is stored in JSON files.</p> <p>Now execute the command <code>allure serve</code> in the root directory of your project. After a few seconds, the Allure Report will open in your browser.</p>"},{"location":"sections/plugins/Allure_Plugin/#some-allure-screenshots","title":"Some Allure Screenshots","text":""},{"location":"sections/plugins/Allure_Plugin/#allure-dashboard","title":"Allure Dashboard","text":""},{"location":"sections/plugins/Allure_Plugin/#test-steps-with-screenshots","title":"Test Steps with Screenshots","text":""},{"location":"sections/plugins/Allure_Plugin/#historic-test-executions","title":"Historic Test Executions","text":"Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/plugins/XRAY_Plugin/","title":"QTAF Xray Plugin","text":"<p>One possibility to export and document test results is Xray for Jira. In this article we show you how to create test cases in Xray, how to link your test cases written in Java with the test cases defined in Xray and how QTAf can automatically save the test results of your test runs in Xray.</p>"},{"location":"sections/plugins/XRAY_Plugin/#create-test-cases-in-xray","title":"Create test cases in Xray","text":"<p>The first step is to create the definitions of our test cases in Xray. In our example, we will create three test case definitions called <code>QTAF-1</code>, <code>QTAF-2</code> and <code>QTAF-3</code>.</p> <p>First you have to click on \"Testing Board\" in the left menu of Jira to get to the user interface of Xray. The following screenshot shows the testing board of our example project. Create the three test case definitions for our test cases here.</p> <p></p> <p>Test steps must still be defined for each of the three tests. In the Xray user interface, these can be found in the \"Test Details\" section. In our example, we assume that the tests <code>QTAF-1</code>, <code>QTAF-2</code> and <code>QTAF-3</code> have two, three and two steps respectively. The following picture shows the test case <code>QTAF-1</code> in Xray:</p> <p></p>"},{"location":"sections/plugins/XRAY_Plugin/#qtaf-and-xray","title":"QTAF and Xray","text":"<p>This section shows how the recorded information about the executed test cases and test steps can be automatically sent to Xray.</p> <p>In addition to <code>qtaf-core</code>, first integrate the dependency <code>qtaf-xray-plugin</code> into your project: Make sure that you use the current version numbers of these modules. You can find them at the Maven Repository</p> <pre><code>&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;de.qytera&lt;/groupId&gt;\n&lt;artifactId&gt;qtaf-core&lt;/artifactId&gt;\n&lt;version&gt;${qtafVersion}&lt;/version&gt;\n&lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;de.qytera&lt;/groupId&gt;\n&lt;artifactId&gt;qtaf-xray-plugin&lt;/artifactId&gt;\n&lt;version&gt;${qtafVersion}&lt;/version&gt;\n&lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>Next we have to store the credentials for Xray in the <code>configuration.json</code> file. To do this, add the following section to this file:</p> <pre><code>{\n...\n\"xray\":{\n\"enabled\": true,\n\"authentication\":{\n\"clientId\": \"&lt;YOUR_CLIENT_ID&gt;\",\n\"clientSecret\": \"&lt;YOUR_CLIENT_SECRET&gt;\"\n}\n},\n...\n}\n</code></pre> <p>Then create three test cases and annotate each with all required annotations. To assign a test class to a test in Xray the annotation <code>@XrayTest</code> must be set for the respective Java method and the attribute <code>key</code> of the annotation must correspond to the key of the test in Xray. The following example shows a test whose results are to be stored in Xray under issua <code>QTAF-1</code>.</p> <pre><code>import de.qytera.qtaf.xray.annotation.XrayTest;\n@TestFeature(\nname = \"DoGoogleSearch\",\ndescription = \"Perform a search for text 'Hello World'\"\n)\npublic class DoGoogleSearch extends TestContext {\n@Test(\ntestName = \"TestGoogleSearch\",\ndescription = \"Type 'Hello World' and click search button\",\ngroups = {\"Group 1\", \"Group 2\"}\n)\n@XrayTest(key = \"QTAF-1\")\npublic void TestCaseGoogleSearch()\n{\n// test logic here\n}\n}\n</code></pre> <p>In order to also document the test steps, methods must be called in the test that are provided with the annotation <code>@Step</code> of the Qtaf framework. In this example, we assume that there are two methods that are defined in a separate class called <code>GoogleFunctionsPage</code>.</p> <pre><code>public class GoogleFunctions extends TestContext\n{\n@Step(\nname = \"Search value\",\ndescription = \"Search for a value\"\n)\npublic void doSearch(String searchValue) {\ndriver.findElement(By.xpath(UsedObject.SearchInputXPath())).sendKeys(searchValue);\ndriver.findElement(By.name(UsedObject.GoogleSearchButtonName())).click();\n}\n@Step(\nname = \"Go to Google home page\",\ndescription = \"Navigate to the Google home page\"\n)\npublic void goToGoogleHome() {\ndriver.get(UsedObject.GoogleHome());\n}\n}\n</code></pre> <p>We then call these methods in the test case.</p> <pre><code>@TestFeature(\nname = \"DoGoogleSearch\",\ndescription = \"Perform a search for text 'Hello World'\"\n)\npublic class DoGoogleSearch extends TestContext\n{\n@Test(\ntestName = \"TestGoogleSearch\",\ndescription = \"Type 'Hello World' and click search button\",\ngroups = {\"Group 1\", \"Group 2\"}\n)\n@XrayTest(key = \"QTAF-1\")\npublic void TestCaseGoogleSearch()\n{\n// 1. Open Google\ngoogleFunctionPage.goToGoogleHome();\n// 2. Execute Search\ngoogleFunctionPage.doSearch(\"Hello World\");\n}\n}\n</code></pre> <p>Qtaf registers the call of these methods and logs the call in the background. Here, no IDs need to be defined for the test steps. Qtaf assigns the called methods in the order of the steps defined in Xray.</p> <p>Now execute your test cases as usual. After the execution of your test cases is finished, QTAF will show you the following statement in the console:</p> <pre><code>15:22:25.717 [main] INFO  de.qytera.qtaf.core - Uploading Xray results ...\n15:22:49.260 [main] INFO  de.qytera.qtaf.core - Uploaded test execution. Key is QTAF-846\n</code></pre> <p>This means that the upload to Xray was successful and can now be viewed in Jira under the key \"QTAF-846\".</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/setup/IntelliJ_Project_Setup/","title":"Setup new QTAF Project with IntelliJ and Maven","text":"<p>Before you read this article you should be familiar with the QTAF framework. You can read this article if you want to understand the Java code which is shown here.</p> <p>To create a new project, we use the IntelliJ IDE from Jetbrains. Here we navigate in the menu to <code>File &gt; New &gt; Project</code> and then select <code>Maven</code> in the left selection menu and click on Next.</p> <p></p> <p>We are then asked for a name for the project. This can be chosen freely, but in this example we use the name \"QtafProject\". It is recommended to also specify the GroupId of the project. This is an identifier for the creator of the project. It is common to choose the company's domain for this, but starting with the country- or organisation-specific ending of the domain. For a company domain \"acme.org\", one would choose the GroupId \"org.acme\" according to this standard. The GroupId can be found in the sub-item <code>Artifact Coordinates</code>. Then we click on <code>Finish</code>. The new project should now have been created in the folder <code>~\\IdeaProjects\\QtafProject</code>, where <code>~</code> is a placeholder for the root directory of the currently logged in user.</p> <p></p> <p>In the root directory of the project we see the file pom.xml. This file is used to configure Maven projects, i.e. to load external libraries, to control the build process, etc.</p> <p>The following additions should be entered in the file:</p> <pre><code>&lt;project&gt;\n&lt;!-- ... --&gt;\n&lt;!-- Here we define the Java version of the project --&gt;\n&lt;properties&gt;\n&lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;\n&lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;\n&lt;/properties&gt;\n&lt;!-- Here you can add external Java libraries to your project --&gt;\n&lt;dependencies&gt;\n&lt;/dependencies&gt;\n&lt;!-- Everything is configured here for the build process --&gt;\n&lt;build&gt;\n&lt;!-- Path under which Java should search for files (resources) --&gt;\n&lt;resources&gt;\n&lt;resource&gt;\n&lt;directory&gt;src/main/resources&lt;/directory&gt;\n&lt;filtering&gt;true&lt;/filtering&gt;\n&lt;/resource&gt;\n&lt;/resources&gt;\n&lt;/build&gt;\n&lt;/project&gt;\n</code></pre> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/setup/VSCode_Project_Setup/","title":"Setup QTAF in VSCode","text":"<p>Before you read this article you should be familiar with the QTAF framework. You can read this article if you want to understand the Java code which is shown here.</p> <p>Front-end developers mostly use VSCode IDE for developing front-end applications, so it is of great importance that they can also start back-end projects with VSCode.</p> <p>To test the QTAF implementation under VSCode, Java 17 should first be installed on the system, there are several tutorials on this. The following instructions show how to install Java 17 on different operating systems:</p> <p>Install Java 17</p> <p>Now check if the installation was sucecssful with the following command:</p> <pre><code>$ java --version\n</code></pre> <p>Now open VSCode and install the extension \"Extension Pack for Java\".</p>  Your browser does not support the video tag.  <p>Furthermore you need to install the extension \"Maven for Java\".</p>  Your browser does not support the video tag.  <p>After installing the necessary extensions, a view \"JAVA PROJECTS\" with the project structure is activated under Explorer.</p> <p></p> <p>To run tests, the Java Pack Extension adds the button \"Run/Debug\" next to the test classes, as in classic Java IDEs (Eclips or Intellij).</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/steps/Data_Providers/","title":"Data Providers","text":"<p>In this article you will learn how to implement data-driven test scenarios with QTAF.</p> <p>In this tutorial, we will assume a test case that is supposed to fill out a form on a website. This test case could look like the example shown:</p> <pre><code>@TestFeature(\nname = \"Calls form\",\ndescription = \"Create call form\"\n)\npublic class CallsTest extends TestContext {\n@Test(testName = \"CallsTest\", description = \"Calls Test\")\npublic void testCalls() {\n//Navigate to calls page\nnavigator.goToRootPage();\ntopNavbar.openMobileMenu();\ntopNavbar.clickMobileCallsMenu();\ncallsPage.clickCallsModuleButton();\ntopBarCallsMenu.clickLogCallLink();\n// Fill call form\ncreateCallForm.fillSubjectField(\"Call subject\");\ncreateCallForm.fillDurationField();\ncreateCallForm.fillDescriptionField(\"Call description\");\ncreateCallPage.clickSaveButton();\n//Navigate to Home page\ntopNavbar.openMobileMenu();\ntopNavbar.clickHomeMenuFromNotHomePage();\n}\n}\n</code></pre> <p>In this example, you see a test scenario called <code>CallsTest</code>, which calls various page objects to eventually fill out a form on a website and submit it afterwards. In this example, the page object <code>createCallForm</code> is responsible for filling out the form, which provides the methods <code>fillSubjectField</code> and <code>fillDescriptionField</code>, among others. Both methods accept a string as parameter.</p> <p>In the example shown, the data we want to enter into the form is statically defined, i.e. no parameters can be passed to the test case from outside. However, if we want this test scenario to run multiple times and with different data, we need to make the following changes to our test scenario.</p>"},{"location":"sections/steps/Data_Providers/#creating-a-data-provider","title":"Creating a Data Provider","text":"<p>First, within our Java class, which in our example is called <code>CallsTest</code>, we create a new method called <code>getCallsData</code>. You are free to choose the name of this method. This method returns a two-dimensional array of type <code>Object[][]</code>. Furthermore, this method must be annotated with the annotation <code>@DataProvider</code> of the TestNG framework. Also, assign an ID of this Data Provider using the <code>name</code> attribute in the DataProvider annotation. The DataProvider could look like this:</p> <pre><code>import org.testng.annotations.*;\n@TestFeature(\nname = \"Calls form\",\ndescription = \"Create call form\"\n)\npublic class CallsTest extends TestContext {\n@DataProvider(name = \"callsData\")\npublic Object[][] getCallsData() {\nreturn new Object[][]{\n{\"Daily\", \"Daily conference\"},\n{\"Weekly\", \"Weekly conference\"},\n{\"Meeting John Doe\", \"Meeting with John Doe\"},\n{\"Meeting Jane Doe\", \"Meeting with Jane Doe\"},\n};\n}\n// ...\n}\n</code></pre> <p>Each test scenario that uses a Data Provider is executed once for each row of the data matrix. In our example, our data provider leifert a data matrix with four rows, accordingly the corresponding test scenarios are executed four times. The columns of the data matrix correspond to the number of parameters passed to the test scenarios. In our example, each execution of a test scenario would be passed two parameters of type String.</p> <p>Now we still need to link our test scenario to our data provider. First, add the attribute <code>dataProvider</code> to the <code>@Test</code> annotation and give this attribute the same value as the attribute <code>name</code> of the <code>@DataProvider</code> annotation. Furthermore, add two parameters of type String to your Java method. Within the test scenario, replace all static parameters with the new dynamic parameters that the method takes. This may look like this:</p> <p>Now you have successfully implemented a data-driven test case. Now run the test case as usual using the mvn clean test command.</p> <pre><code>@Test(testName = \"CallsTest\", description = \"Calls Test\", dataProvider = \"callsData\")\npublic void testCalls(String subject, String description) {\n//Navigate to calls page\nnavigator.goToRootPage();\ntopNavbar.openMobileMenu();\ntopNavbar.clickMobileCallsMenu();\ncallsPage.clickCallsModuleButton();\ntopBarCallsMenu.clickLogCallLink();\n// Fill call form\ncreateCallForm.fillSubjectField(subject);\ncreateCallForm.fillDurationField();\ncreateCallForm.fillDescriptionField(description);\ncreateCallPage.clickSaveButton();\n//Navigate to Home page\ntopNavbar.openMobileMenu();\ntopNavbar.clickHomeMenuFromNotHomePage();\n}\n</code></pre> <p>You have now successfully implemented a data-driven test case. Now run the test case as usual using the <code>mvn clean test</code> command.</p>"},{"location":"sections/steps/Drivers/","title":"QTAF Drivers","text":"<p>This article explains how to use QTAF to test on different browsers easily and without changing your source code.</p>"},{"location":"sections/steps/Drivers/#what-are-drivers","title":"What are drivers?","text":"<p>A driver provides an interface between the test framework and the browser or the device with which a (web) application is to be tested. For example, if a web application is to be developed and it should run on the most common browsers, it is advisable to test the application automatically. This requires an interface between the test framework (for example Selenium) and the browser (Chrome, Firefox, Edge, Safari, ...). For each browser there is a driver that abstracts the details of how the browser is controlled and thus enables the tester to test his test cases with different browsers without changing his code.</p> <p>QTAF relieves the tester of the initialisation of a driver object. The tester only has to specify via the configuration file which browser he wants to use for testing.  To do this, he enters the name of the driver in the attribute <code>driver.name</code> of the configuration file. Alternatively, the environment variable <code>DRIVER_NAME</code> can be set or the parameter <code>-Ddriver.name</code> can be passed via the command line when executing the test cases.</p>"},{"location":"sections/steps/Drivers/#list-of-selenium-driver-configurations-provided-by-qtaf","title":"List of Selenium driver configurations provided by QTAF","text":"<p>The following is a list of Selenium drivers provided by the QTAF framework and the names you have to set for the parameter <code>driver.name</code> to use these.</p> Driver driver.name Description ChromeDriver chrome Driver for testing on a Chrome browser. ChromeRemoteDriver chrome-remote Driver for testing on a Chrome browser that is accessible via a network connection. EdgeDriver edge Driver for testing on an Edge browser. EdgeRemoteDriver edge-remote Driver for testing on an Edge browser that is accessible via a network connection. FirefoxDriver firefox Driver for testing on a Firefox browser. FirefoxRemoteDriver firefox-remote Driver for testing on a Firefox browser that is accessible via a network connection. OperaDriver opera Driver for testing on an Opera browser. OperaRemoteBrowser opera-remote Driver for testing on an Opera browser that is accessible via a network connection. InternetExplorerDriver ie Driver for testing on an Internet Explorer browser. SaucelabsDriver sauce Driver for testing on the Saucelabs platform"},{"location":"sections/steps/Drivers/#use-a-local-browser-for-testing","title":"Use a local browser for testing","text":"<p>QTAF uses the Webdrivermanager, so there is no need to install a Selenium driver on your PC. However, you must ensure that the desired browsers are installed on your PC. To test on a local browser, set the following configuration parameters:</p> Configuration parameter Value Description driver.name \u201cchrome\u201d | \u201cfirefox\u201d | \u201cedge\u201d | \u201copera\u201d | \u201cie\u201d Name of the drivers <p>This is already sufficient for QTAF to be able to execute the test cases on the desired browser. When executing the test cases, QTAF automatically starts the browser and executes the test cases in it.</p>"},{"location":"sections/steps/Drivers/#running-test-cases-on-a-remote-browser","title":"Running test cases on a remote browser","text":"<p>The Selenium driver and QTAF do not have to be on the same computer. It is also possible to connect QTAF to remote drivers via a network connection. Use cases for this include Docker environments or virtual machines running a Selenium driver. To do this, set the following configuration parameters:</p> Configuration parameter Value Description driver.name \u201cchrome-remote\u201d | \u201cfirefox-remote\u201d | \u201copera-remote\u201d Name of the browser / driver to be used driver.remoteUrl <code>&lt;remote url&gt;</code> URL under which the Selenium driver can be reached, e.g. 10.0.0.1:5555/wd/hub <p>For Docker, there are already pre-configured images that you can use out of the box. For example, you can create the following Docker Compose file and then connect to the Selenium containers.</p> <pre><code>version: '3'\nservices:\n# Selenium chrome\nselenium-chrome:\nimage: selenium/standalone-chrome-debug\nports:\n- '4444:4444'\nrestart: always\n# Selenium firefox\nselenium-firefox:\nimage: selenium/standalone-firefox-debug\nports:\n- '4445:4444'\nrestart: always\n# Selenium opera\nselenium-opera:\nimage: selenium/standalone-opera-debug\nports:\n- '4446:4444'\nrestart: always\n</code></pre> <p>Assuming that the containers are running on your local machine, you need to set the following values for your configuration parameters:</p> Treiber driver.name driver.RemoteUrl Chrome chrome 127.0.0.1:4444/wd/hub Firefox firefox 127.0.0.1:4445/wd/hub Opera opera 127.0.0.1:4446/wd/hub"},{"location":"sections/steps/Drivers/#running-test-cases-on-the-saucelabs-platform","title":"Running test cases on the Saucelabs platform","text":"<p>QTAF can also run test cases on virtual machines provided by the Saucelabs platform. In order for QTAF to connect to Saucelabs virtual machines, the following configuration values must be set.</p> Configuration parameter Value Description driver.remoteUrl https://ondemand.eu-central-1.saucelabs.com/wd/hub URL under which the Selenium driver from Saucelabs can be reached. See also the following link. driver.name sauce driver.version <code>&lt;driver_version&gt;</code> version of the driver / browsers sauce.browserName <code>&lt;browser_name&gt;</code> Name of the browser (Chrome, Firefox, \u2026), see link driver.platform <code>&lt;platform_name&gt;</code> Name of the platform (Windows 10, Windows 11, \u2026), see link sauce.username <code>&lt;username&gt;</code> Saucelabs username (use environment variables for this configuration parameter for security reasons) sauce.accessKey <code>&lt;access_key&gt;</code> Saucelabs access key (use environment variables for this configuration parameter for security reasons)"},{"location":"sections/steps/Drivers/#writing-your-own-drivers","title":"Writing your own drivers","text":"<p>In some scenarios, QTAF's pre-configured drivers may not meet the tester's needs. In this case, QTAF offers the possibility to write your own driver class and use it during testing. </p> <p>Let us assume for the following scenario that you want to test on a browser for which QTAF does not provide a corresponding driver. However, you have found a library that provides such a Selenium-compatible driver and now want to use this driver with QTAF. Proceed as follows:</p> <p>Create a package in your Java project in which you want to write the driver class. In this example, this is the package <code>org.acme.driver</code>.</p> <p>In this package, create a class that implements the class <code>de.qytera.qtaf.core.driver.AbstractDriver</code>. In our example, this class is called <code>MyDriver</code>. Now you have to implement the following methods: <code>getName</code> and <code>getDriver</code>. The method <code>getName</code> returns the name of the browser to be used in the configuration file. The <code>getDriver</code> method returns a driver object that implements the <code>WebDriver</code> interface of the Selenium framework.</p> <pre><code>package org.acme;\nimport de.qytera.qtaf.core.driver.AbstractDriver;\nimport org.openqa.selenium.WebDriver;\npublic class MyDriver extends AbstractDriver {\n@Override\npublic String getName() {\nreturn \"my-driver\"; // Replace this with your own name\n}\n@Override\npublic WebDriver getDriver() {\nreturn new SampleDriver(); // Replace this with your own driver implementation\n}\n}\n</code></pre> <p>In order for QTAF to be able to find your implementation of the driver, you must also enter the name of the package in which the driver is to be found in the configuration file. You can also enter several packages here. QTAF will scan this package for all classes that implement the <code>AbstractDriver</code> interface.</p> <pre><code>{\n\"framework\": {\n\"packageNames\": [\n\"org.acme.driver\"\n]\n}\n}\n</code></pre> <p>Now you have to enter the name of your driver in the configuration file.</p> <pre><code>{\n\"driver\": {\n\"name\": \"my-driver\"\n}\n}\n</code></pre> <p>Now you can run your tests with the new driver.</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/steps/HTML_Report_Plugin/","title":"The HTML Report Plugin","text":"<p>The QTAF HTML report plugin offers the possibility to create an HTML report from the log messages generated by QTAF, which can then be opened in a browser.</p> <p>The HTML report plugin is included in the QTAF framework by default. You do not need to add any dependencies other than the QTAF framework itself in your <code>pom.xml</code> file.</p> <p>You can view an example of an HTML report from QTAF here: QTAF HTML Report</p>"},{"location":"sections/steps/HTML_Report_Plugin/#activating-the-html-report-plugin","title":"Activating the HTML Report Plugin","text":"<p>In addition to <code>qtaf-core</code>, first integrate the dependency <code>qtaf-html-report-plugin</code> into your project: Make sure that you use the current version numbers of these modules. You can find them at the Maven Repository</p> <pre><code>&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;de.qytera&lt;/groupId&gt;\n&lt;artifactId&gt;qtaf-core&lt;/artifactId&gt;\n&lt;version&gt;0.0.3&lt;/version&gt;\n&lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;de.qytera&lt;/groupId&gt;\n&lt;artifactId&gt;qtaf-html-report-plugin&lt;/artifactId&gt;\n&lt;version&gt;0.0.3&lt;/version&gt;\n&lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>To activate the HTML-Report-Plugin you have to set the value <code>htmlReport.enabled</code> in the configuration file to true. Then run your test cases.</p> <pre><code>{\n\"htmlReport\": {\n\"enabled\": true\n}\n}\n</code></pre>"},{"location":"sections/steps/HTML_Report_Plugin/#displaying-the-html-reports","title":"Displaying the HTML reports","text":"<p>You will find the HTML reports in the folder <code>./logs</code> relative to the root directory of your project. The generated HTML files can be opened in any browser. Let's now take a look at the structure of the report.</p> <p>First, the report shows you general information about the execution of the test cases, such as the execution time of the test suite, start and end dates, and the Selenium driver used.</p> <p></p> <p>Below this information you will find a list of the test features that the executed test suite contains. In this example, these are the test features <code>QTAF-496</code> and <code>QTAF-567</code>. The names of the test features come from the annotation <code>@TestFeature</code> of the respective Java classes that represent the respective test features.</p> <pre><code>@TestFeature(\nname = \"QTAF-496\",\ndescription = \"Login to the CRM\"\n)\n@Singleton\npublic class LoginFeature extends TestContext {\n@Test(\ntestName = \"QTAF-496\",\ndescription = \"Login Test\"\n)\npublic void testLogin(){\nnavigator.goToRootPage();\nloginForm.fillUsernameField(\"user\");\n// ...\n}\n}\n</code></pre> <p></p> <p>Below the respective test features you can see a list of the test scenarios that contain the test features. Test scenarios are represented in TestNG by the methods of a test class, which are provided with the annotation <code>@Test</code>. The name of the scenarios displayed in the HTML report comes from the attribute <code>name</code> of this annotation.</p> <p>If we now click on the button to the right of the scenario name, we get more details about the executed test scenario. On the one hand, we see the full path of the class and the method it contains, which represents the scenario shown. In this example, this would be the class <code>de.qytera.suite_crm.Logintest.testLogin</code>. This ensures the traceability of the test results to the test definitions. Further information displayed in the report are the start and end times of the execution of the test scenario as well as its duration.</p> <p></p> <p>But the report contains even more information about the executed test cases. Now click on the button to the right of \"Steps\" to get information about the individual test steps of the scenario.</p> <p>You will now see a list of the test steps of the test scenario. Each test step listed in the report corresponds to the call of a Java method annotated with the annotation <code>@Step</code>. In our example, these are the methods <code>goToRootPage</code> and <code>fillUsernameField</code>. These come respectively from the two page object classes <code>Navigator</code> and <code>LoginFormPO</code>. These page object classes could look like this:</p> <pre><code>@Singleton\npublic class Navigator extends SuiteCRMTestContext {\n@Step(\nname = \"Go to SuiteCRM main page\",\ndescription = \"Navigate to the SuiteCRM main home page\"\n)\npublic void goToRootPage() {\nString url = \"http://127.0.0.1:80\";\ndriver.get(url);\n}\n}\n</code></pre> <pre><code>@Singleton\npublic class LoginFormPO extends SuiteCRMTestContext {\nprotected String usernameFieldId = \"user_name\";\n// ...\n@Step(name = \"Fill username field\", description = \"Fill the username field\")\npublic void fillUsernameField(String username) {\ndriver.findElement(By.id(usernameFieldId)).sendKeys(username);\n}\n// ...\n}\n</code></pre> <p>In the HTML report, you can see that the individual steps contain information about the complete package path of these methods. Thus, traceability between test steps and test documentation is also guaranteed for the test steps.</p> <p>Furthermore, you can also see that the passed parameters of the test steps are documented. For example, a parameter of the type string with the value <code>\"user\"</code> was passed to the method <code>fillUsernameField</code>.</p> <p></p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/steps/New_QTAF_Project/","title":"How to create a new QTAF project","text":"<p>This article shows how a new project can be set up using the QTAF framework. First, we will show you how to install QTAF using Maven. Then we will create our first test case using QTAF.</p>"},{"location":"sections/steps/New_QTAF_Project/#set-up-a-new-project-with-intellij","title":"Set up a new project with IntelliJ","text":"<p>To create a new project, we use the IntelliJ IDE from Jetbrains. Here we navigate in the menu to <code>File &gt; New &gt; Project</code> and then select <code>Maven</code> in the left selection menu and click on <code>Next</code>.</p> <p>We are then asked for a name for the project. This can be chosen freely, but in this example we use the name \"QtafProject\". It is recommended to also specify the GroupId of the project. This is an identifier for the creator of the project. It is common to choose the company's domain for this, but starting with the country- or organisation-specific ending of the domain. For a company domain \"acme.org\", one would choose the GroupId \"org.acme\" according to this standard. The GroupId can be found in the sub-item Artifact Coordinates. Then we click on Finish. The new project should now have been created in the folder <code>~\\IdeaProjects\\QtafProject</code>, where <code>~</code> is a placeholder for the root directory of the currently logged in user.</p> <p>In the root directory of the project we see the file <code>pom.xml</code>. This file is used to configure Maven projects, i.e. to load external libraries, to control the build process, etc. The file should look like this:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n&lt;groupId&gt;org.acme&lt;/groupId&gt;\n&lt;artifactId&gt;QtafProject&lt;/artifactId&gt;\n&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/project&gt;\n</code></pre> <p>This file can be used to manage plug-ins and extensions of the project. Now we only have to include QTAF as a dependency in the project. To do this, add the following code to pom.xml:</p> <pre><code>&lt;dependency&gt;\n&lt;groupId&gt;de.qytera&lt;/groupId&gt;\n&lt;artifactId&gt;qtaf-core&lt;/artifactId&gt;\n&lt;version&gt;${qtafVersion}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Replace <code>${qtafVersion}</code> by the version number with the latest version of QTAF. You can find this in the Central Maven Repository under the following link: QTAF Central Repository</p>"},{"location":"sections/steps/New_QTAF_Project/#overview-of-the-project-structure","title":"Overview of the project structure","text":"<p>After creating the project, a file called <code>pom.xml</code> should have been created in the root directory of the project with the following content.</p>"},{"location":"sections/steps/New_QTAF_Project/#create-test-cases","title":"Create test cases","text":""},{"location":"sections/steps/New_QTAF_Project/#create-first-test-case","title":"Create first test case","text":"<p>Now the project should be initialised. We can now devote ourselves to creating the first test case.</p> <p>First we create the package <code>org.acme.tests</code> in the directrory <code>src/test/java</code>, where we will store our test case classes in the future. Create a class <code>TestOne</code> in this package with the following content:</p> <pre><code>package org.acme.tests;\nimport de.qytera.qtaf.core.config.annotations.TestFeature;\nimport de.qytera.qtaf.testng.context.QtafTestNGContext;\nimport org.testng.annotations.Test;\n@TestFeature(\nname = \"TestCase One\",\ndescription = \"First test\"\n)\npublic class TestOne extends QtafTestNGContext {\n@Test(testName = \"Test Success\", description = \"This test should pass\")\npublic void testSuccess() {\nassertEquals(2 * 2, 4);\n}\n@Test(testName = \"Test Failure\", description = \"This test should fail\")\npublic void testFailure() {\nassertEquals(2 * 2, 3);\n}\n}\n</code></pre>"},{"location":"sections/steps/New_QTAF_Project/#run-tests","title":"Run tests","text":"<p>You can run the tests in two ways. In the first case, you can run the tests via the command line with the command <code>mvn clean test</code>. In our example, one test should succeed and the second test should fail. The output on the command line should end with the following text:</p> <pre><code>Results :\n\nFailed tests:   testFailure(org.acme.tests.TestOne): expected [3] but found [4]\n\nTests run: 2, Failures: 1, Errors: 0, Skipped: 0\n\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  15.570 s\n[INFO] Finished at: 2023-01-01T11:04:36+01:00\n[INFO] ------------------------------------------------------------------------\n</code></pre> <p>The second option is to run tests using the IntelliJ IDE. To do this, click on the green triangles next to the test methods in the <code>TestOne</code> class to run individual tests or on the green triangle next to the <code>TestOne</code> class itself and then click on Run test in the menu that opens to run all tests.</p> <p>You will now see the following things: New directories and files have been created in your project. A new file named <code>qtaf.json</code> has been created in the resource directory. Within this file you can define parameters for the test execution.</p> <p>A new directory called <code>logs</code> has also been created. In this directory, you can now observe that for each test run, a subdirectory is created that contains information about the test run.</p>"},{"location":"sections/steps/New_QTAF_Project/#create-a-selenium-test-case","title":"Create a Selenium test case","text":"<p>QTAF has been developed with a particular focus on web application testing and therefore offers special support for Selenium test cases. The Selenium library has already been installed by including QTAF as a dependency in your Maven project. To create a new Selenium test case, we proceed as in the example shown earlier. First we create a test class called <code>SeleniumTest</code> and let this class inherit from <code>QtafTestNGContext</code>. Now we again create a method within this class and provide it again with the annotation <code>@Test</code>from TestNG.</p> <p>The class <code>QtafTestNGContext</code> provides us with the <code>driver</code> object, with which we can control our browser. The <code>driver</code>object is an ordinary Selenium web driver object, which we can work with as usual from other Selenium projects. The documentation of the Selenium driver for Java including a small example can be found on the following website: Selenium Documentation</p> <p>We would now like to look at how we would write the test case described in the Selenium documentation using QTAF. The Selenium test case without QTAF looks like this:</p> <pre><code>import org.testng.Assert;\nimport org.testng.annotations.Test;\npublic class HelloSeleniumTest {\nBy headlineSelector = By.cssSelector(\"h1.display-1\");\n@Test(\ntestName = \"Open browser and visit selenium documentation\",\ndescription = \"Open the browser and go to the selenium documentation website\"\n)\npublic void testBrowser() {\n// Instatiate WebDriver object\nWebDriver driver = new ChromeDriver();\n// Visit Selenium documentation\ndriver.get(\"https://selenium.dev\");\n// Extract headline text from website\nString headlineText = driver.findElement(headlineSelector)).getText();\nAssert.assertEquals(headlineText, \"Selenium automates browsers. That's it!\");\n// Close the driver\ndriver.quit();\n}\n}\n</code></pre> <p>If we now use QTAF, our test case looks like this:</p> <pre><code>import de.qytera.qtaf.core.config.annotations.TestFeature;\nimport de.qytera.qtaf.testng.context.QtafTestNGContext;\nimport org.testng.Assert;\nimport org.testng.annotations.Test;\n@TestFeature(\nname = \"SeleniumTest\",\ndescription = \"Our first Selenium test\"\n)\npublic class HelloSeleniumTest extends QtafTestNGContext {\nBy headlineSelector = By.cssSelector()\"h1.display-1\";\n@Test(\ntestName = \"Open browser and visit selenium documentation\",\ndescription = \"Open the browser and go to the selenium documentation website\"\n)\npublic void testBrowser() {\n// Visit Selenium documentation\ndriver.get(\"https://selenium.dev\");\n// Extract headline text from website\nassertEquals($(headlineSelector).text(), \"Selenium automates browsers. That's it!\");\n}\n}\n</code></pre> <p>We only need to do two things to convert an ordinary TestNG test case into a QTAF test case:</p> <ol> <li>The class must be annotated with the <code>TestFeature</code> annotation, which is provided by the QTAF library.</li> <li>Our class must inherit from <code>QtafTestNGContext</code>.</li> </ol> <p>If we look at the code inside the method we notice two more things: The statements for instantiating and closing the webdriver have been removed. QTAF takes over these tasks for us and already provides us with the initialised driver object via the class attribute <code>driver</code>.</p> <p>A QTAF test case is thus an ordinary TestNG test case that we have merely extended with an annotation and an inherited class. Thus, every TestNG test case can also be converted into a QTAF test case.</p>"},{"location":"sections/steps/New_QTAF_Project/#divide-test-cases-into-test-steps-and-page-objects","title":"Divide test cases into test steps and page objects","text":"<p>Now that we have created our first test case we can move on to restructuring our test case. In our test case we have carried out two main steps: First, we called the desired page in the browser and then we extracted the text of a web element from the page using a selector. Then we checked whether this text corresponds to the text we wanted. Some of these test steps might also be of interest in other test cases, especially calling the website using <code>driver.get()</code> might occur more often in our test cases. Therefore, it makes sense to outsource these test steps to their own methods. First, we could create three methods within the test class into which we outsource the code of the respective test steps. In the test case, only these methods are called. Especially if the test steps become more complex in the course of a test project, it makes sense to split the code into methods. In our example, these test methods could look like this:</p> <pre><code>package org.acme.tests;\nimport de.qytera.qtaf.core.config.annotations.TestFeature;\nimport de.qytera.qtaf.testng.context.QtafTestNGContext;\nimport org.testng.Assert;\nimport org.testng.annotations.Test;\n@TestFeature(\nname = \"SeleniumTest\",\ndescription = \"Our first Selenium test\"\n)\npublic class HelloSeleniumTest extends QtafTestNGContext {\nBy headlineSelector = By.cssSelector()\"h1.display-1\";\n@Test(\ntestName = \"Open browser and visit selenium documentation\",\ndescription = \"Open the browser and go to the selenium documentation website\"\n)\npublic void testBrowser() {\nopenSite(\"https://selenium.dev\");\ncheckHeadline(\"Selenium automates browsers. That's it!\");\n}\npublic void openSite(String url) {\n// Visit Selenium documentation\ndriver.get(url);\n}\npublic void checkHeadline(String expectedText) {\n// Extract headline text from website\nassertEquals($(headlineSelector).text(), expectedText);\n}\n}\n</code></pre> <p>The advantages of this code example are obvious: the code becomes more readable and by outsourcing test steps to separate methods, they can also be reused in other test cases. However, QTAF goes one step further and expects methods that represent test steps to be defined in separate classes. Thus, there are classes in which the methods contain test cases and other classes in which the methods only contain test steps. Instead of defining all test steps within a single class, it makes sense to bundle only those test steps within a class that all address a specific area of the website. Areas of the website can be, for example, a login form, a navigation bar or a specific menu. This also contributes to the maintainability of the code in larger projects.</p> <p>Let's now look at how to define such a page object class in QTAF. We first create the package <code>org.acme.page_objects</code>, in which we will define our page object classes. The name of the package can also be chosen differently. In this package we now create the class <code>MainSitePO</code>. Within this class we define the methods <code>openSite</code> and <code>checkHeadline</code> as we had defined them before in the class <code>HelloSeleniumTest</code>. Then we have to add annotations to our new class. We add the annotation <code>@Step</code> to each method that represents a test step. Within this annotation we can define the attributes name and description. The name and description of the test step will be used later in the reporting.</p> <p>Our new page object class should look like this:</p> <pre><code>package org.acme.page_objects;\nimport de.qytera.qtaf.core.guice.annotations.Step;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebElement;\nimport javax.inject.Singleton;\npublic class MainSitePO extends QtafTestNGContext {\nBy headlineSelector = By.cssSelector()\"h1.display-1\";\n@Step(\nname = \"Open Site\",\ndescription = \"Open the selenium documentation website in the browser\"\n)\npublic void openSite(String url) {\n// Visit Selenium documentation\ndriver.get(url);\n}\n@Step(\nname = \"Check Headline\",\ndescription = \"Check if the headline of the site cintains a specific text\"\n)\npublic void checkHeadline(String expectedText) {\n// Extract headline text from website\nassertEquals($(headlineSelector).text(), expectedText);\n}\n}\n</code></pre> <p>Now we need to instantiate this page object class in out test case. This can be done by the function <code>load</code> that is provided by the QTAF test context. This function accepts a class reference and creates a new instance of this class. It is important to instantiate the page object by calling the <code>load</code>and not using the <code>new</code>keyword, otherwise logging will not work for this page object. Internally QTAF injects code before and after each step method so that we can trace these functions. Our test case class, which now uses our page object class, then looks like this:</p> <pre><code>package org.acme.tests;\nimport de.qytera.qtaf.core.config.annotations.TestFeature;\nimport de.qytera.qtaf.testng.context.QtafTestNGContext;\nimport org.testng.annotations.Test;\n@TestFeature(\nname = \"SeleniumTest\",\ndescription = \"Our first Selenium test\"\n)\npublic class HelloSeleniumTest extends QtafTestNGContext {\n@Test(\ntestName = \"Open browser and visit selenium documentation\",\ndescription = \"Open the browser and go to the selenium documentation website\"\n)\npublic void testBrowser() {\n// Instantiate page objects\nMainSitePO mainSitePO = load(MainSitePO.class)\n// Test case\nmainSitePO.openSite(\"https://selenium.dev\");\nmainSitePO.checkHeadline(\"Selenium automates browsers. That's it!\");\n}\n}\n</code></pre> <p>Now we have divided our project into page objects and the test steps defined in them. We can now call the main method of <code>TestRunner</code> or execute the command <code>mvn clean test</code>. This will run our test cases.</p>"},{"location":"sections/steps/New_QTAF_Project/#create-reports","title":"Create reports","text":"<p>QTAF offers you the possibility to automatically create reports from your test runs. In this example we show you two reporting formats integrated into the QTAF framework, one documenting the test execution by means of a JSON document and the other one creating an HTML report. The JSON document is interesting for the machine processing of the test results, the HTML report for the testers as a graphical presentation of the test results.</p> <p>First, we need to add the QTAF HTML Report plugin as a dependency to our project. To do this, add the following dependency to the pom.xml file.</p> <pre><code>&lt;dependency&gt;\n&lt;groupId&gt;de.qytera&lt;/groupId&gt;\n&lt;artifactId&gt;qtaf-html-report-plugin&lt;/artifactId&gt;\n&lt;version&gt;${qtafVersion}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Furthermore we have to activate the creation of the HTML report in the <code>qtaf.json</code> file. Make sure that the value <code>htmlReport.enabled</code> in the configuration file is set to <code>true</code>:</p> <pre><code>  \"htmlReport\":{\n\"enabled\":true\n}\n</code></pre> <p>Then run the test cases again by executing the main method of the <code>TestRunner</code> class. You will then find the file <code>Report.html</code> in the logs directory, which contains the HTML report. You can open and display this in any browser.</p> <p>Furthermore, in the same directory you will find the file <code>Report.json</code>, which contains the data of the test run as a JSON document.</p> <p>You can find an example of an HTML report here: QTAF HTML Report</p> <p>You can also find an example JSON report here: QTAF JSON Report</p>"},{"location":"sections/steps/New_QTAF_Project/#run-test-cases-on-different-browsers","title":"Run test cases on different browsers","text":"<p>QTAF offers you the possibility to run test cases on different browsers. You can tell QTAF in three different ways which browser it should use to run the test cases. The only requirement is that the browsers themselves have already been installed by you on your computer. QTAF will automatically download the appropriate Selenium drivers for the desired browsers. You therefore do not need to worry about setting up the appropriate drivers.</p> <p>Option 1: Use the configuration file</p> <p>Change the value of the <code>driver.name</code> attribute in the <code>qtaf.json</code> file. Possible values include <code>chrome</code>, <code>firefox</code>, <code>edge</code>, <code>opera</code> and <code>ie</code>.</p> <pre><code>  \"driver\":{\n\"name\": \"chrome\"\n}\n</code></pre> <p>Then run your test cases as usual. For example, if you have selected <code>firefox</code> as the value, the test cases will now be executed in the Firefox browser.</p> <p>Option 2: Use the command line</p> <p>QTAF test cases can also be executed via the command line. This is advantageous if you want to run test cases in a pipeline on different browsers, as in this case you do not have to make any changes to the code base. To run test cases from the command line you have to execute the command <code>mvn clean test</code>. Please note that the package name <code>org.acme</code> may differ from project to project. You can also pass the desired browser using the argument <code>-Ddriver.name</code>. For the Firefox browser, the command would look like this: <code>mvn clean test -Ddriver.name=\"firefox\"</code>. Command line arguments always overwrite the values in the configuration file, i.e. if you have set the value <code>chrome</code> for <code>driver.name</code> in the configuration file, but pass the value <code>firefox</code> via the command line, your test cases will ultimately be executed in the Firefox browser.</p> <p>Option 3: Use environment variables</p> <p>As a third option, QTAF offers to set configuration parameters via environment variables. For example, if you want to test on the Edge browser, set the environment variable <code>DRIVER_NAME</code> to the value <code>edge</code>. In a Bash shell, you can also set environment variables directly before the actual command. This would look like this: <code>DRIVER_NAME=edge mvn clean test</code>. Environment variables also always overwrite the values in the <code>qtaf.json</code> file.</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"}]}