{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>On the following pages you can find instructions for the product QTAF.</p>"},{"location":"#content","title":"Content","text":""},{"location":"#basics-of-test-automation","title":"Basics of Test Automation","text":"<ul> <li>The Page Object Model</li> <li>How to create a new project with IntelliJ</li> <li>How to create a new project with VSCode</li> </ul>"},{"location":"#first-steps-with-qtaf","title":"First steps with QTAF","text":"<ul> <li>How to create your first QTAF project</li> <li>Use Data Providers in your test scenarios</li> <li>Exploring the HTML report</li> <li>How to run your tests against different browsers using QTAF<ul> <li>Connect QTAF to a remote driver</li> <li>Running test cases on the Saucelabs platform</li> <li>Write your own drivers</li> </ul> </li> </ul>"},{"location":"#use-qtaf-with-kotlin-and-groovy","title":"Use QTAF with Kotlin and Groovy","text":"<ul> <li>Create a Kotlin QTAF project with Maven / Gradle</li> <li>Create a Groovy QTAF project with Maven / Gradle</li> </ul>"},{"location":"#qtaf-plugins","title":"QTAF Plugins","text":"<ul> <li>Xray Plugin</li> <li>TestRail Plugin</li> <li>Allure Plugin</li> </ul>"},{"location":"#qtaf-and-cucumber","title":"QTAF and Cucumber","text":"<ul> <li>Create a QTAF Cucumber project</li> </ul>"},{"location":"#dive-deeper-into-qtaf","title":"Dive deeper into QTAF","text":"<ul> <li>How the QTAF logging system works</li> <li>Setup QTAF Locally</li> <li>Which Annotations does QTAF provide?</li> </ul> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/Configuration/","title":"Configuration","text":"<p>Here you can find descriptions, examples and use cases for all global QTAF settings.</p>"},{"location":"sections/Configuration/#driver","title":"<code>driver</code>","text":"<p>The driver settings are essential for the web driver to properly interact with your application.</p>"},{"location":"sections/Configuration/#options","title":"<code>options</code>","text":"<p>A list of browser options to pass to the web driver on instantiation.</p> Environment variable <code>DRIVER_OPTIONS</code> Type <code>string[]</code> Example QTAF JSONEnvironment variable <pre><code>\"driver\": {\n  \"options\": [\n    \"--headless\",\n    \"--disable-gpu\",\n    \"--ignore-certificate-errors\",\n    \"--disable-extensions\",\n    \"--no-sandbox\",\n    \"--disable-dev-shm-usage\"\n  ]\n}\n</code></pre> <pre><code>DRIVER_OPTIONS=\"[--headless, --disable-gpu, --ignore-certificate-errors, --disable-extensions, --no-sandbox, --disable-dev-shm-usage]\"\n</code></pre>"},{"location":"sections/Configuration/#capabilities","title":"<code>capabilities</code>","text":"<p>A capabilities object to pass to the web driver on instantiation.</p> Environment variable <code>DRIVER_CAPABILITIES</code> Type <code>JSON object</code> Example QTAF JSONEnvironment variable <pre><code>\"driver\": {\n  \"capabilities\": {\n    \"acceptInsecureCerts\": true,\n    \"elementScrollBehavior\": 1,\n    \"customCapability\": [42, \"yes\", false]\n  }\n}\n</code></pre> <pre><code>DRIVER_CAPABILITIES=\"{acceptInsecureCerts: true, elementScrollBehavior: 1, customCapability: [42, yes, false]}\"\n</code></pre>"},{"location":"sections/Configuration/#preferences","title":"<code>preferences</code>","text":"<p>Additional browser preferences to pass to the web driver options on instantiation.</p> <p>Info</p> <p>These preferences will be passed to the driver options as follows:</p> <ul> <li>Chromium: as experimental options</li> <li>Firefox: as a firefox profile</li> </ul> Environment variable <code>DRIVER_PREFERENCES</code> Type <code>JSON object</code> Example QTAF JSONEnvironment variable <p>The following will set the download directory in Chromium-based browsers to <code>/home/me/downloads</code>.</p> <pre><code>\"driver\": {\n  \"preferences\": {\n    \"prefs\": {\n      \"download.default_directory\": \"/home/me/downloads\"\n    }\n  }\n}\n</code></pre> <pre><code>DRIVER_PREFERENCES=\"{prefs: {download.default_directory: /home/me/downloads}}\"\n</code></pre>"},{"location":"sections/Configuration/#download-directory","title":"Download Directory","text":""},{"location":"sections/Configuration/#chromium-based-drivers","title":"Chromium-based drivers","text":"<p>You can set the download directory for Chrome and Edge in the following way:</p> <pre><code>\"preferences\": {\n  \"download\": {\n    \"default_directory\": \"C:\\\\Users\\\\your_username\",\n    \"prompt_for_download\": false,\n    \"directory_upgrade\": true\n  }\n}\n</code></pre>"},{"location":"sections/Configuration/#firefox","title":"Firefox","text":"<p>When using the firefox webdriver you can change the download directory in the following way:</p> <pre><code>\"preferences\": {\n  \"browser.download.folderList\": 2,\n  \"browser.download.manager.showWhenStarting\": false,\n  \"browser.download.dir\": \"C:\\\\Users\\\\your_username\",\n}\n</code></pre>"},{"location":"sections/Configuration/#using-variables","title":"Using variables","text":"<p>You can also use the expressions <code>$USER_DIR</code> and <code>$USER_HOME</code> in your download path. <code>$USER_HOME</code> will be replaced by the home directory of the currently logged in user and <code>$USER_DIR</code> by the directory where the QTAF project is stored in.</p> <p>For example you can save the downloads (for Chromium based drivers) in the <code>resources</code> directory of your project with the following configuration:</p> <pre><code>\"preferences\": {\n  \"download\": {\n    \"default_directory\": \"$USER_DIR/src/test/resources\",\n}\n</code></pre> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/Page_Object_Model/","title":"Page Object Model","text":"<p>The Page Object Model is a software design pattern that describes interfaces for software-controlled manipulation of an element of a graphical user interface. The basic idea of the Page Object Model is to describe and control elements of a GUI through a parameterisable code base. The page object model is often used in the software-based automation of software applications with a graphical user interface.</p> <p>There are two basic ways to select elements of a graphical user interface: First, each element can be assigned a unique ID. On the other hand, there is the possibility to select elements by means of a query language. A page object consists of a set of selectors that identify one or more elements of a GUI by means of an ID or a query language. In the context of web applications, GUI elements are mainly identified by unique IDs, CSS or HTML attributes. Furthermore, methods are defined in a page object that can perform a manipulation on one or more elements of the web application or read their attributes. The attributes of a GUI element are, for example, information about the graphic representation of the element (height, width, colours, etc.), its position on the display device and its relationship to other elements of the GUI.</p>"},{"location":"sections/Page_Object_Model/#example-of-page-objects","title":"Example of page objects","text":"<p>The following HTML code is an example of a page object for a website. The page object shown consists of four basic elements: An image, a headline, a text and a button.</p> <p></p> <p>This is the corresponding HTML source code of the shown UI element:</p> <pre><code>&lt;div&gt;\n    &lt;img\n    src=\"https://www.qytera.de/sites/default/files/startseite-2020/qytera-testmanagement-300-169.jpg\" alt=\"\" class=\"startseite-saeulen-logo\" /&gt;\n    &lt;h3&gt;Continuous Testing&lt;/h3&gt;\n    &lt;p&gt;Wir verhelfen Ihnen zu kontinuierlichen und schnellen Softwarelieferungen in hoher Qualit\u00e4t.&lt;/p&gt;\n    &lt;form action=\"https://www.qytera.de/testing-solutions/continuous-testing\" method=\"get\"&gt;\n        &lt;button class=\"button-red consulting-blog-verlinkung-button\"&gt;Mehr erfahren&lt;/button&gt;\n    &lt;/form&gt;\n&lt;/div&gt;\n</code></pre> <p>In test automation, a class is now created in which methods for interacting with the elements of the page object are defined. Useful methods for interacting with the page object shown could be reading the headline and the text as well as clicking the button.</p> <p>The following is an example of the definition of a page object using the Java programming language. The root node of the page object is passed to the class in the constructor. Subsequently, references to the UI elements (image, heading, text and button) are stored in the class attributes. Furthermore, methods for interacting with the page object are defined in the class, such as reading out the texts of the elements or other attributes such as the URL of the image.</p> <pre><code>public class CardPageObject {\n    HTMLImageElement image;\n    HTMLElement headline;\n    HTMLParagraphElement paragraph;\n    HTMLButtonElement button;\n\n    CardPageObject(WebElement rootElement) {\n        image = (HTMLImageElement) rootElement.findElement(By.cssSelector(\"img.startseite-saeulen-logo\"));\n        headline = (HTMLElement) rootElement.findElement(By.cssSelector(\"h3\"));\n        paragraph = (HTMLParagraphElement) rootElement.findElement(By.cssSelector(\"p\"));\n        button = (HTMLButtonElement) rootElement.findElement(By.cssSelector(\"button.button-red\"));\n    }\n\n    String getImageSource() {\n        return image.getAttribute(\"src\");\n    }\n\n    String getHeadlineText() {\n        return headline.getAttribute(\"innerText\");\n    }\n\n    String getParagraphText() {\n        return paragraph.getAttribute(\"innerText\");\n    }\n\n    void clickButton() {\n        ((WebElement) button).click();\n    }\n}\n</code></pre> <p>On the website examined, UI elements with a similar structure to the one shown can be found. From the point of view of test automation, it makes no sense to abstract each of these objects with its own page object class. Instead, it makes more sense to create a common class for these page objects and to pass parameters to this class that can be used to react to deviations between the individual page objects.</p> <p></p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/cucumber/New_Cucumber_Project/","title":"Create a Cucumber Project with QTAF","text":"<p>This article describes how to set up a QTAF Cucumber project. It is assumed that you have already set up a Maven project using IntelliJ and have included QTAF as a dependency. How this can be done is described in the following article: QTAF - Project Creation. Also you can use our QTAF with Cucumber example project to try it out.</p>"},{"location":"sections/cucumber/New_Cucumber_Project/#create-folder-and-package-structure","title":"Create folder and package structure","text":"<p>The Java code of the Maven project is stored in the subfolder <code>src/main/java</code>, the resources (all other required files) in the subfolder <code>src/main/resources</code>.</p> <p>Within the Java directory we create the package <code>org.acme</code>, because in this example we are creating a project for the fictitious company Acme GmbH. Furthermore, we create the folder <code>features</code> in the <code>resources</code> directory, which will later contain our feature files.</p>"},{"location":"sections/cucumber/New_Cucumber_Project/#creating-test-cases","title":"Creating test cases","text":"<p>To create test cases using Qtaf with Cucumber, we first need to create a so-called test runner. This test runner is a class that provides information about the location of the Cucumber feature files and the step definitions by means of an annotation.</p> <p>In the following example we assume that our source code is organised in the package <code>org.acme</code>. We create a new class in this package called <code>TestRunner</code>. This class must have the following properties:</p> <ol> <li>The class will have the annotation <code>@CucumberOptions</code>. This annotation provides information on where to find the feature files <code>(features = {\"...\"})</code>, where to find the corresponding step definitions <code>(glue = {\"...\"})</code>, which tag (not) to run <code>(tags = \"...\")</code> and which Cucumber plugin to use to create the reports <code>(plugin = {\"...\"})</code>.</li> <li>The <code>TestRunner</code> class must inherit from the CucumberQtafTestContext class.</li> <li>The <code>TestRunner</code> class must contain a method that is annotated with the <code>@DataProvider</code> annotation of the TestNG framework and returns a list of scenarios, which is done by calling <code>super.scenarios()</code>.</li> </ol> <p>The following code shows a sample implementation of this class:</p> <pre><code>package org.acme;\n\nimport de.qytera.qtaf.cucumber.context.QtafTestNGCucumberContext;\nimport io.cucumber.testng.CucumberOptions;\nimport org.testng.annotations.DataProvider;\n\n/**\n * Main class to execute Cucumber Tests\n */\n@CucumberOptions(\n        features = {\"src/main/resources/features\"},\n        glue = {\"org.acme.stepdefs\"},\n        tags = \"\",\n        plugin = {\"pretty\"}\n)\npublic class TestRunner extends QtafTestNGCucumberContext {\n    @Override\n    @DataProvider(parallel = true)\n    public Object[][] scenarios() {\n        return super.scenarios();\n    }\n}\n</code></pre>"},{"location":"sections/cucumber/New_Cucumber_Project/#creating-a-scenario-listener","title":"Creating a scenario listener","text":"<p>In order for QTAF to be able to create log files for the executed test cases, you have to create another class in the folder you specified in the <code>@CucumberOptions</code> annotation in the <code>glue</code> attribute. In this case, this would be the folder <code>org.acme.stepdefs</code>.</p> <p>In this folder, create a class called <code>TestListener</code> that inherits from the QTAF framework class <code>QtafCucumberHooks</code> and add the following methods to it:</p> <pre><code>package org.acme.stefdefs;\n\nimport de.qytera.qtaf.cucumber.listener.QtafCucumberHooks;\nimport io.cucumber.java.*;\n\n/**\n * This class listens to cucumber hooks and produces logs\n */\npublic class TestListener extends QtafCucumberHooks {\n    @Before\n    public void onBeforeScenario(Scenario scenario) {\n        beforeScenario(scenario);\n    }\n\n    @After\n    public void onAfterScenario(Scenario scenario) {\n        afterScenario(scenario);\n    }\n\n    @BeforeStep\n    public void onBeforeStep(Scenario scenario) {\n        beforeStep(scenario);\n    }\n\n    @AfterStep\n    public void onAfterStep(Scenario scenario) {\n        afterStep(scenario);\n    }\n}\n</code></pre> <p>Cucumber will automatically recognise this class as a listener class through the annotations <code>@Before</code>, <code>@BeforeStep</code>, <code>@After</code> and <code>@AfterStep</code>. Within this methods, we let the QTAF framework perform the further steps for logging by calling these methods.</p>"},{"location":"sections/cucumber/New_Cucumber_Project/#creating-feature-files","title":"Creating feature files","text":"<p>In the <code>TestRunner</code> class we have specified that the feature files are to be found in the <code>src/main/resources/features</code> directory relative to the root directory of our project. In this folder we now place our first feature file with the name <code>GoogleSearch</code>.feature. The name of the file can be freely chosen. As long as the file ends with <code>.feature</code> and is located in the directory that we specified with the annotation <code>@CucumberOptions</code>, Cucumber is able to find this file and interpret it as a test case.</p> <p>Now we write the following content into our feature file:</p> <pre><code># Test the Qytera search function\nFeature: Qytera Search\n\n  # This step will run before each scenario\n  Background: The browser will be launched\n    Given Launch the browser\n\n  # Test case 1\n  @TestName:QTAF-1\n  Scenario: Search for Cucumber in Qytera\n    Then Enter \"Cucumber\" in the search text box\n    And Select the first result\n</code></pre>"},{"location":"sections/cucumber/New_Cucumber_Project/#creating-step-definitions","title":"Creating Step Definitions","text":"<p>Step definitions are Java classes that contain the code to be executed when a step is called in a feature file. For example, if we have defined the step <code>Then Enter \"Cucumber\" in the search text box</code> in our feature file, Cucumber does not yet know what to do when it sees this statement. To tell Cucumber this, we create a new class called <code>StepDefs</code> in the package <code>org.acme.stepdefs</code>. We have previously defined the package name via the annotation <code>@CucumberOptions</code>. Furthermore, classes that contain step definitions must inherit from the class <code>QtafTestNGContext</code>.</p> <p>In the following example, all steps are defined that are called in our feature file. Among other things, this class provides the attribute <code>driver</code>, which provides an instance of a web driver.</p> <pre><code>package org.acme.stepdefs;\n\nimport de.qytera.qtaf.core.context.QtafTestContext;\nimport io.cucumber.java.en.Given;\nimport io.cucumber.java.en.Then;\nimport io.cucumber.java.en.When;\nimport org.openqa.selenium.WebDriver;\nimport org.testng.Assert;\n\npublic class StepDef extends QtafTestContext {\n\n    @Given(\"Launch the browser\")\n    public void launchTheBrowser() {\n        driver.get(\"https://www.qytera.de\");\n    }\n\n    @When(\"Hit Qytera on your browser\")\n    public void hitQytera() {\n        Assert.assertEquals(3, 3);\n    }\n\n    @Then(\"Enter {string} in the search text box.\")\n    public void enterStringInSearchBox(String string) {\n        System.out.println(\"Search box: \" + string);\n    }\n\n    @Then(\"Select the first result.\")\n    public void selectTheFirstResult() {\n        Assert.assertEquals(1, 1);\n    }\n}\n</code></pre>"},{"location":"sections/cucumber/New_Cucumber_Project/#run-program","title":"Run program","text":"<p>Now the project is ready so that we can run it for the first time. To do this, we click on an icon with a green file to the left of the name of the main class in IntelliJ. A dialogue then opens where we click on Run <code>CucumberRunner</code>. This first run allows QTAF to create further required directories and files on its own.</p> <p></p> <p>A browser will open for a short time. However, since we have not yet created any test cases, it will close again after a short time. Furthermore, a configuration file called <code>qtaf.json</code> is created in the resource directory, as well as the folder <code>logs</code>, in which you can already see log files for the test run we have just carried out.</p> <p>The project is now ready for the creation of test cases.</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/design_patterns/Design_Patterns/","title":"QTAF Test Automation Design Patterns","text":"<p>As projects grow it is neccessary that code is readable and maintainable. Design patterns help to master large projects and they help other developers understanding the code. In this article we want to introduce you to the most convenient design patterns in test automation with QTAF.</p>"},{"location":"sections/design_patterns/Design_Patterns/#lazy-loading-with-the-supplier-pattern","title":"Lazy Loading with the Supplier Pattern","text":"<p>Why lazy loading?</p> <p> The supplier pattern helps you to deal with page objecs. For complex sites it can be neccessary to build nested page objects where you have a parent page objects that represents a whole page and child page objects that represent fractions of that site. When we have nested page objects it can be neccessary to pass web elements between two page objects, for example if the parent page objects wants to delegate the responsibility for some fraction of a page to a child page object and need to tell the child page object what its root element is. The parent page objects would instantiate these child objects and then pass the root web element of the page fraction to them. But this can lead to untraceability of web elements, because at construction time of the child page object the page fraction might not be available. Also in long lasting test cases elements can become stale, because the page might have been reloaded or changed during the test case. There needs to be a mechanism that loads the web elements that the parent page object provided only at the time when they are needeed. </p> <p>Different approaches</p> <p> We have different options how we can do this. The first option would be to fetch a web element by its selector and then pass it to the child page object. But this comes at a high risk of getting a StaleElementException. If the child page object is used multiple times in a test case it may be neccessary to reload a web element, but in this case this wouldn't be possible because the child page opbject has no information about how the web element was selected. </p> <p> A possible solution for this problem would be that we can pass a selector instead of a web element to a child object. This enabled the page object to reload a web element every time we query it. With that technique it is possible to load web elements when they are needed and not when the child object is instantiated by its parent page object. This technique is also called \"Lazy Loading\". But there is a third option which is veen better than passing a selector to the child object. We also can pass a reference to a function which the child page object can call to get a web element. This is even more powerfull then passing the selector to the child page object, because we can add any logic to the creation process of the web element. </p> <p>Supplier functions</p> <p> Function that accepts no arguments and return an object of type `T` have a special functional interface in Java which is named `Supplier`. When we construct a child page object that represents a fraction of a page we can pass a function to this child page object which can load the root web element of the page franction when it is needed. This pattern is similar to the observer pattern, where an observer can register functions in a subject that are executed when a certain event occurs. In the supplier design pattern the parent page objects provides methods for its child page objects that help them to load their own root web element. That is the whole idea of the supplier pattern: not the parent class decides when the web element is wanted but the child page object does.  <p>Implementation in QTAF</p> <p> Now lets look how we can implement the supplier pattern in QTAF. We assume that we want to model the following web page. The parent page object should model the complete page which starts at the div element with the id \"root\". The child page object should model the fraction of the page that is wrapped by the `` tag. This would be the root web element of the child page object.  <pre><code>&lt;div id=\"root\"&gt;\n    &lt;article&gt;\n        &lt;h1&gt;Article 1&lt;/h1&gt;\n        &lt;div&gt;Lorem Ipsum&lt;/div&gt;\n    &lt;/article&gt;\n&lt;/div&gt;\n</code></pre> <p>First we define the parent page object. It has a method named <code>getArticle()</code> which accepts no arguments and returns a <code>SelenideElement</code> object. This matches the definition of a supplier function.</p> <pre><code>public class ParentPageObject extends QtafTestNGContext {\n    public SelenideElement getArticle() {\n        return $(\"article\");\n    }\n}\n</code></pre> <p>Now lets look at the code of the child page object. This page object has a method named <code>setParent(Supplier&lt;SelenideElement&gt;)</code> which can be used by parent page objects to provide the root web element of the page fraction. The function reference is stored in a class attribute named <code>parent</code>. The supplier function itself is of type <code>Supplier&lt;SelenideElement&gt;</code>. Because the attribute is a function reference it is up to the child page object when this method is called. A function reference which is stored in a variable or a class attribute can be called by the expression <code>&lt;attribute-name&gt;</code>.get(). The child page object has methods for getting the headline and the text of the article, which first get the article web element by calling the function stored in the <code>parent</code> attribute and then calling a selector function on the returned web element.</p> <pre><code>public class ChildPageObject extends QtafTestNGContext {\n    private Supplier&lt;SelenideElement&gt; parent;\n\n    public ChildPageObject setParent(Supplier&lt;SelenideElement&gt;) {\n        this.parent = parent;\n    }\n\n    public SelenideElement getHeadline() {\n        return parent.get().$(\"h1\").shouldBe(visible);\n    }\n\n    public SelenideElement getText() {\n        return parent.get().$(\"div\").shouldBe(visible);\n    }\n}\n</code></pre> <p>Last we need a function in the parent page object that constructs the child page objects and passes the parent web element to it. First we get an instance of the child page object with the <code>load()</code> method of <code>QtafTestNGContext</code>. Then we call the <code>setParent()</code> method of the created instance, whcih receives a reference to the function <code>getArticle</code> as an argument. References to functions are notated by the expression <code>this::&lt;function-name&gt;</code> without parenthesis in Java. Finnaly we return the created page object. With this approach you can create multiple instances of a page object class that have different parent web elements.</p> <pre><code>public class ParentPageObject extends QtafTestNGContext {\n    public SelenideElement getArticle() {\n        return $(\"article\");\n    }\n\n    public ChildPageObject getChildPageObject() {\n        return load(ChildPageObject.class).setParent(this::getArticle)\n    }\n}\n</code></pre>"},{"location":"sections/dive/Overview_Annotations/","title":"QTAF Annotations","text":"<p>This article shows which annotations QTAF provides. Furthermore, all annotations provided by TestNG are supported.</p>"},{"location":"sections/dive/Overview_Annotations/#qtaf-annotations_1","title":"QTAF Annotations","text":"<p>QTAF makes it possible to quickly and easily name or describe test cases and more directly in the code by using the annotations provided. This information allows for more detailed log files and reports. In addition, some QTAF plug-ins also offer further annotations.</p>"},{"location":"sections/dive/Overview_Annotations/#general","title":"General","text":""},{"location":"sections/dive/Overview_Annotations/#step","title":"@Step","text":"<p>The annotation <code>@Step</code> is used for methods that represent a test step.</p> <p>This annotation has the following attributes :</p> <ul> <li> <p><code>name</code>: Name of the step</p> </li> <li> <p><code>description</code> : Description of the step</p> </li> </ul> <p>These attributes are used when generating log files and reports.</p>"},{"location":"sections/dive/Overview_Annotations/#testfeature","title":"@TestFeature","text":"<p>The annotation <code>@TestFeature</code> is used to annotate classes that contain test cases.</p> <p>This annotation expects the following attributes:</p> <ul> <li> <p><code>name</code>: Name of the test feature</p> </li> <li> <p><code>description</code>: Description  of the test feature</p> </li> </ul> <p>These attributes are used when generating log files and reports.</p> <p>The following annotation can be used to describe a test feature and associated test cases in a class: <pre><code>import de.qytera.qtaf.core.config.annotations.TestFeature;\nimport org.testng.annotations.Test;\n\n@TestFeature(\n        name = \"Test Feature One\",\n        description = \"This is the first test feature\"\n)\npublic class TestFeatureOne extends TestContext {\n\n    @Test(testName = \"T1\", description = \"First Test Case\")\n    public void testOne() {\n        // ...\n    }\n}\n</code></pre> For a description of the <code>@Test</code> annotation, see also the section TestNG Annotations.</p>"},{"location":"sections/dive/Overview_Annotations/#plug-ins","title":"Plug-ins","text":"<p>QTAF can be extended with plug-ins. Some of these plug-ins offer annotation. More detailed information on the corresponding plug-ins can be found in their documentation.</p>"},{"location":"sections/dive/Overview_Annotations/#testrail","title":"@TestRail","text":"<p>The annotation <code>@TestRail</code> can be used to describe a TestRail test case.</p> <p>This annotation has the following the attributes:</p> <ul> <li> <p><code>caseId</code>: ID of the test case</p> </li> <li> <p><code>runId</code>: ID of a test run. (Like a test plan ID)</p> </li> </ul> <p>These attributes are used when generating log files and reports.</p>"},{"location":"sections/dive/Overview_Annotations/#xraytest","title":"@XrayTest","text":"<p>The annotation <code>@XrayTest</code> can be used to configure documentation to test results in Xray.</p> <p>This annotation has the following the attributes:</p> <ul> <li> <p><code>key</code>: Internal Xray test ID that can be used for uploading test execution results.</p> </li> <li> <p><code>scenarioReport</code>: Indicates whether an HTML report should be added as evidence to this test. (default is false)</p> </li> <li> <p><code>screenshots</code> : Indicates whether screenshots should be added as evidence to this test. (default is false)</p> </li> </ul> <p>These attributes are used when generating log files and reports.</p>"},{"location":"sections/dive/Overview_Annotations/#testng-annotations","title":"TestNG Annotations","text":"<p>All annotations provided by TestNG are supported by QTAF. This includes <code>@Test</code>, <code>@Parameters</code>, <code>@BeforeSuite</code> etc. A complete list of TestNG annotations can be found in the official TestNG documentation.</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/dive/Overview_Logging/","title":"QTAF Logging","text":"<p>This article explains how the log files of QTAF are structured, how they are represented internally in the QTAF framework and how new log entries are created at runtime.</p>"},{"location":"sections/dive/Overview_Logging/#structure-of-the-log-files","title":"Structure of the log files","text":"<p>QTAF assumes a hierarchical structure of test cases and bases the naming of the test hierarchy on the test framework Cucumber. At the top is the test suite, which contains test features. In the QTAF framework, all test classes annotated with <code>@TestFeature</code> form such a test suite.</p> <p>A test feature is a list of test cases (scenarios) that perform similar tests, for example testing the behaviour of a button on a web page. In the QTAF framework, scenarios are implemented using methods within TestFeature classes. These methods are provided with the annotation <code>@Test</code> of the TestNG framework.</p> <p>A scenario, in turn, can be subdivided into test steps. Steps are implemented in QTAF by means of methods, which are provided with the annotation <code>@Step</code>. These methods are usually stored in separate page object classes so that they can be used in several scenarios.</p> <p></p> <p>QTAF log files are also hierarchically structured and represent the structure described above. The top level is the so-called <code>SuiteLogCollection</code>. This is a data object that contains the data about all tested features. Within this object there is a list of <code>FeatureLog</code> objects, which in turn contain a list of <code>ScenarioLog</code> objects. Finally, these contain a list of <code>StepLog</code> objects.</p> <p></p>"},{"location":"sections/dive/Overview_Logging/#the-class-testsuitelogcollection","title":"The class TestSuiteLogCollection","text":"<p>To start logging, an instance of the class <code>TestSuiteLogCollection</code> must first be created. This is done by QTAF at the beginning of the test execution, you as a user do not have to take care of this process. This class follows the singleton design pattern, that means that there is exactly one instance of this class at runtime. QTAF therefore assumes that exactly one test suite is executed within a single process. You can get the instance of the class by calling <code>QtafFactory.getTestSuiteLogCollection()</code> anywhere in your code. Inside the <code>TestSuiteLogCollection</code> class, general information about the test suite is collected, such as the name of the test suite and the start and end time of testing, the name of the driver used, and the duration of the testing process. Exactly one JSON logfile is created from an instance of TestSuiteLogCollection after all test scenarios have been run. This log file contains the information shown.</p> <pre><code>{\n  \"suiteInfo\": {\n    \"name\": \"MyTestSuite\",\n    \"outputDir\": \"C:\\\\Users\\\\myuser\\\\MyTestProject\"\n  },\n  \"driverName\": \"chrome\",\n  \"start\": \"Feb 26, 2021, 1:19:58 PM\",\n  \"end\": \"Feb 26, 2021, 1:21:21 PM\",\n  \"duration\": 83393,\n  \"testFeatureLogCollection\": [\n     // Test Feature Logs ...\n  ]\n}\n</code></pre>"},{"location":"sections/dive/Overview_Logging/#the-testfeaturelogcollection-class","title":"The TestFeatureLogCollection class","text":"<p>The next hierarchy level below the test suite are the test features. This is a grouping of test cases, which in QTAF are called test scenarios. Test scenarios are represented by a class in TestNG. In Cucumber, test scenarios are organised in feature files. The test suite is then the set of all test classes / feature files. For each class / feature file, an instance of the class <code>TestFeatureLogCollection</code> is created and given a unique ID. In Java-based frameworks such as TestNG / JUnit, this ID corresponds to the class name in which the test scenario was defined, in Cucumber it corresponds to the name of the feature file. If you try to create a new instance of a <code>TestFeatureLogCollection</code> with an existing ID, the existing instance is returned and no new instance is created. Within the log file, the data about the recorded test features is stored in the attribute <code>testFeatureLogCollection</code>. This data includes the unique ID of the feature, its name and description, and a list of information about all test scenarios of the feature.</p> <pre><code>// ...\n  \"testCaseLogCollection\": [\n    {\n      \"classId\": \"tests.DoGoogleSearch\",\n      \"testCaseAnnotation\": {\n        \"name\": \"DoGoogleSearch\",\n        \"description\": \"Perform a search for text \\u0027Hello World\\u0027\"\n      },\n      \"testSzenarioLogCollection\": [\n        // Test Szenario Logs ...\n      ]\n// ...\n</code></pre>"},{"location":"sections/dive/Overview_Logging/#the-class-testscenariologcollection","title":"The class TestScenarioLogCollection","text":"<p>The class <code>TestScenarioLogCollection</code> is the next hierarchical class below <code>TestFeaturelogCollection</code>.  For each executed test case, an instance of this class is created and the information about the executed test case is stored in it. Within TestNG / JUnit, test scenarios are represented by class methods annotated with <code>@Test</code>. QTAF records information such as the start and end time of a test case, the name and description of the test case and its status (passed / failed / not executed).</p> <p>Test scenarios are also assigned a unique ID, which in TestNG / JUnit is composed of the class name plus the method name and in Cucumber by the name of the feature file plus the scenario name. This naming is always unique and enables the traceability of the test results to the test cases.</p> <p>Within the log file, the results are stored in the attribute testSzenarioLogCollection of the features and look like this:</p> <pre><code>// ...\n      \"testLogCollection\": [\n        {\n          \"uniqueId\": 224219987,\n          \"methodId\": \"tests.DoGoogleSearch.TestCaseGoogleSearch\",\n          \"testId\": \"QTAF-1\",\n          \"description\": \"Type \\u0027Hello World\\u0027 and click search button\",\n          \"start\": \"Feb 26, 2021, 1:19:58 PM\",\n          \"end\": \"Feb 26, 2021, 1:20:10 PM\",\n          \"duration\": 11992,\n          \"groups\": [],\n          \"groupDependencies\": [],\n          \"methodDependencies\": [],\n          \"testParameters\": [],\n          \"status\": \"FAILURE\",\n          \"logMessages\": [\n            // Step Logs\n          ]\n        },\n        // ... Weitere Szenario Logs\n      ]\n// ...\n</code></pre> <p>In the following example, the relationship between features and scenarios is explained using a TestNG example. The class itself represents a feature, the three methods it contains are the test scenarios. The set of all test classes forms the test-suite.</p> <pre><code>public class MyTestFeature {\n\n  @Test()\n  public void testScenario1() {\n    // ...\n  }\n\n  @Test()\n  public void testScenario2() {\n    // ...\n  }\n\n  @Test()\n  public void testScenario3() {\n    // ...\n  }\n\n}\n</code></pre>"},{"location":"sections/dive/Overview_Logging/#the-logmessage-class","title":"The LogMessage class","text":"<p>Now the lowest level of the log hierarchy comes into play. Test cases, which are methods themselves, can be broken down into further methods. This enables the reuse of code and increases its readability. Each of these methods is called a \"step\" in QTAF. Accordingly, the log messages documenting the call of these methods are called \"StepLogs\" and are represented by the class <code>StepLogMessage</code>. Here, however, only method calls are recorded where the method itself is provided with the annotation <code>@Step</code> of the Qtaf framework. This gives you full control over which methods should be recorded and which should not. Each <code>StepLogMessage</code> instance contains information about the name of the called method, the status (passed, failed, not executed) and the start and end time of the execution of the method.</p> <p>Within the logfile, the information about the executed step methods is stored within the keyword logMessages of the test scenario logs. A StepLog entry in the logfile looks like this:</p> <pre><code>// ...\n          \"logMessages\": [\n            {\n              \"type\": \"STEP_LOG\",\n              \"methodName\": \"pageobjects.googlePage.GoogleFunctions.goToGoogleHome\",\n              \"step\": {\n                \"name\": \"Go to Google home page\",\n                \"description\": \"Navigate to the Google home page\"\n              },\n              \"status\": \"PASSED\",\n              \"start\": \"Feb 26, 2021, 1:19:58 PM\",\n              \"end\": \"Feb 26, 2021, 1:20:00 PM\",\n              \"duration\": 1761,\n              \"stepParameters\": [],\n              \"level\": \"INFO\",\n              \"message\": \"Step Go to Google home pageexecuted\"\n            },\n            // ...\n          ]\n// ...\n</code></pre>"},{"location":"sections/dive/Overview_Logging/#creation-of-log-objects-at-runtime","title":"Creation of log objects at runtime","text":"<p>QTAF provides its own listener class for the test frameworks TestNG and Cucumber, with which it reacts to the events triggered by these frameworks. Since the data that TestNG and Cucumber transmit by means of these events differ greatly in their structure, QTAF implements a translation layer (transformer) for these events and translates the data they contain into its own data structure. This makes the event subscribers independent of the test framework used.</p> <p>After QTAF has translated the events of the test framework used into its own data structure, it informs its subscribers about this. They can now process the triggered events and the transmitted data. This event system can also be used to develop your own plug-ins.</p> <p>The following diagram shows the process from the creation to the processing of the event.</p> <p></p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/dive/Setup_QTAF_Locally/","title":"Local Setup of QTAF","text":"<p>In this article we describe how QTAF can downloaded and installed locally. This should be done if you want to use beta verisons of QTAF, develop own plugins or add modifications of the code.</p> <p>We assume that you have already cloned the QTAF source code from the GitHub repository to your machine. Otherwise navigate to a directory of your choice and execute the following command: </p> <pre><code>$ git clone https://github.com/Qytera-Gmbh/QTAF\n</code></pre> <p>You can then start editing the QTAF source code.</p> <p>If you would like to try out your changes locally first, you can proceed as follows.</p> <ol> <li> <p>Set a new version number for QTAF. This version number should contain the addition \"LOCAL\" to make it clear that it is only a locally developed version that is not to be deployed to the central repository. For example, you could assign the version number \"LOCAL-2022-11-14-001\". Since the QTAF project is divided into several modules and each of these modules has its own POM file, it can be tedious and error-prone to update the version number of each POM file. Instead, you can run the command <code>mvn versions:set \"-DnewVersion=&lt;version&gt;\"</code> to update the version numbers of all modules.</p> </li> <li> <p>Then run the command <code>mvn clean install</code> to install the current version of QTAF locally. This may take some time as all test cases will also be executed. If you want to skip the test cases you can append the option <code>-DskipTests=true</code> to the command.</p> </li> <li> <p>After the installation has been completed, you can integrate the new, local QTAF version in other projects via the POM file.</p> </li> </ol> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n    &lt;artifactId&gt;qtaf-core&lt;/artifactId&gt;\n    &lt;version&gt;LOCAL-2022-11-14-001&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>For example, use demo projects such as the SuiteCRM demo project to test the changes to the QTAF framework and their effects.</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/faq/FAQ/","title":"FAQ","text":"When running <code>mvn:exec</code>, I get an error message <code>java.lang.ClassNotFoundException: some.package.TestRunner</code>. Make sure to run <code>mvn install -DskipTests</code> first."},{"location":"sections/plugins/Allure_Plugin/","title":"Allure Plugin","text":"<p>This article is about installing the tool Allure, which you can use to generate test reports.</p> <p>First we need to take care of the installation of Allure. Go to the Central Repository page: Allure CLI and download the file called <code>allure-commandline-*.zip</code>, replacing <code>*</code> with the latest version. Unzip it to a directory of your choice. Inside the directory where you saved Allure you will find the folder <code>bin</code>. Add this to the environment variable <code>PATH</code>. Then open a terminal and enter the command <code>allure</code>. You should see a list of possible commands for the Allure CLI.</p>"},{"location":"sections/plugins/Allure_Plugin/#alternative-installation-possibility-with-scoop","title":"Alternative installation possibility with Scoop","text":"<p>Scoop is a command line installation programme for Windows. With Scoop you can install programs and plugins for your terminal.</p> <ol> <li>Open PowerShell. You can do this by searching for PowerShell in the Start menu.</li> <li>Type the following in PowerShell: <code>iwr -useb get.scoop.sh | iex</code></li> <li>Press the Enter key. PowerShell will now install Scoop.</li> </ol> <p>If you get an error message regarding ExecutionPolicy after entering the command line, enter the following command in PowerShell:</p> <pre><code>Set-ExecutionPolicy RemoteSigned -scope CurrentUser.\n</code></pre> <p>This will change the <code>ExecutionPolicy</code> for your account to remote signed and you can install Scoop. After installing Scoop, you can access Scoop Help in PowerShell or Command Prompt to get a list of Scoop commands.</p> <p>After you have installed Scoop, open PowerShell and enter the following command:</p> <pre><code>scoop install allure\n</code></pre> <p>You can verify that Allure is installed correctly by opening a terminal and typing <code>allure</code>. You should see a list of possible commands for the Allure CLI.</p>"},{"location":"sections/plugins/Allure_Plugin/#the-qtaf-allure-plugin","title":"The QTAF Allure Plugin","text":"<p>In addition to <code>qtaf-core</code>, first integrate the dependency <code>qtaf-allure-plugin</code> into your project: Make sure that you use the current version numbers of these modules. You can find them at the Maven Repository</p> <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n        &lt;artifactId&gt;qtaf-core&lt;/artifactId&gt;\n        &lt;version&gt;0.0.3&lt;/version&gt;\n        &lt;scope&gt;compile&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n        &lt;artifactId&gt;qtaf-allure-plugin&lt;/artifactId&gt;\n        &lt;version&gt;0.0.3&lt;/version&gt;\n        &lt;scope&gt;compile&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>Check the Maven Central repository for the current version of the plugin.</p> <p>This completes the installation of the Allure plugin. In the <code>configuration.json</code> file, you can now add the following options for taking screenshots, which will then be included in the Allure report:</p> <pre><code>\"driver\":{\n  \"name\": \"chrome\",\n  \"screenshots\": {\n    \"beforeScenario\": true,\n    \"afterScenario\": true,\n    \"beforeStep\": true,\n    \"afterStep\": true\n  }\n}\n</code></pre> <p>You can then run your test cases as usual. After the test cases have been executed, the QTAF Allure plugin automatically creates the folder <code>allure-results</code> in the root directory of your project. This is where the data for the Allure report is stored in JSON files.</p> <p>Now execute the command <code>allure serve</code> in the root directory of your project. After a few seconds, the Allure Report will open in your browser.</p>"},{"location":"sections/plugins/Allure_Plugin/#some-allure-screenshots","title":"Some Allure Screenshots","text":""},{"location":"sections/plugins/Allure_Plugin/#allure-dashboard","title":"Allure Dashboard","text":""},{"location":"sections/plugins/Allure_Plugin/#test-steps-with-screenshots","title":"Test Steps with Screenshots","text":""},{"location":"sections/plugins/Allure_Plugin/#historic-test-executions","title":"Historic Test Executions","text":"Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/plugins/Create_Plugin/","title":"Creating a new module / plugin","text":"<p>This article describes how to create a new QTAF module. Module b\u00fcndeln den Code von Plugins oder Bibliotheken. Beispiele f\u00fcr existierende QTAF-Module sind <code>qtaf-allure-plugin</code>, <code>qtaf-xray-plugin</code>, <code>qtaf-io</code>, <code>qtaf-http</code>.</p>"},{"location":"sections/plugins/Create_Plugin/#prerequisites","title":"Prerequisites","text":"<ul> <li>Clone the QTAF repository to your PC.</li> <li>Make sure that GPG is installed on your PC. Pr\u00fcfen Sie dies mit dem Befehl <code>gpg --version</code>. Wenn GPG nicht installiert ist befolgen Sie diese Anleitung, um GPG zu installieren</li> <li>First install QTAF locally. You can find the corresponding instructions here</li> </ul>"},{"location":"sections/plugins/Create_Plugin/#create-a-new-module","title":"Create a new module","text":"<ol> <li>open the QTAF project in IntelliJ</li> <li>click on <code>File &gt; New &gt; Module</code> in the menu </li> <li>then select <code>Maven Archetype</code> in the left side menu. You will then be asked for the name, the GroupId, the ArtifactId and the version number of the new module. For GroupId select <code>en.qytera</code>, the ArtifactId can be freely selected. The name of the module should be identical to the ArtifactId and the version number identical to the version number of the parent module <code>qtaf</code>. Then click on the \"Finish\" button. A new folder should then have been created in the project with the name of the new module. In this folder you will find the POM file of the new module. 4. </li> <li>add the <code>qtaf-core</code> dependency to the POM file of the new module  5 After the local installation, you can integrate the new module as a dependency in a local project. </li> <li>create the packages <code>en.qytera.qtaf.&lt;modulename&gt;</code> in the <code>src/main/java</code> folder of your new module, whereby <code>&lt;modulename&gt;</code> can be freely selected by you. However, the package <code>&lt;modulename&gt;</code> must be in the package <code>en.qytera.qtaf</code>. Otherwise, dependency injections of the QTAF framework will not work, as certain classes such as EventSubscriber are always searched for in packages that are in the namespace <code>en.qytera.qtaf</code>.  You can create the new directories by right-clicking on your module folder in the QTAF project. After right-clicking, navigate to New &gt; Directory. Then select the four standard directories and click Enter. </li> <li>create another package called event_subscriber in the <code>&lt;modulename&gt;</code> package</li> <li>create a class in the package <code>event_subscriber</code> that implements the interface <code>IEventSubscriber</code> of the QTAF framework. Using the event subscriber, plug-ins can react to events generated by the QTAF framework. For example, you can subscribe to the <code>beforeLogsPersisted</code> event to process the data of the current test run. You can use the following sample code to display a message on the console as soon as the data is available:</li> </ol> <p><pre><code>package de.qytera.qtaf.testray.event_subscriber;\n\nimport de.qytera.qtaf.core.events.QtafEvents;\nimport de.qytera.qtaf.core.events.interfaces.IEventSubscriber;\nimport de.qytera.qtaf.core.log.model.collection.TestSuiteLogCollection;\nimport rx.Subscription;\n\npublic class UploadResultsSubscriber implements IEventSubscriber {\n\n    /**\n     * Subscription reference\n     */\n    Subscription onBeforeLogsPersistedSub;\n\n    @Override\n    public void initialize() {\n        this.onBeforeLogsPersistedSub = QtafEvents.beforeLogsPersisted.subscribe(\n                this::onBeforeLogsPersisted\n        );\n    }\n\n    /**\n     * Event handler @param logCollection Log collection\n     */\n    private void onBeforeLogsPersisted(TestSuiteLogCollection logCollection) {\n        System.out.println(\"Hello World! Here is the QTAF Testray Plugin. \" +\n                \"This method is executed before the log files are persisted\");\n    }\n}\n</code></pre> Further information about the QTAF event system can be found in this article. You can now implement your own logic for processing the test data within the <code>onBeforeLogsPersisted</code> method. An exemplary (albeit not very useful) method would be to output all names of test features and test scenarios as well as all associated log messages to the console. This would look like this:</p> <p><pre><code>    /**\n     * Event handler @param logCollection Log collection\n     */\n    private void onBeforeLogsPersisted(TestSuiteLogCollection logCollection) {\n        System.out.println(\"Hello World! Here is the QTAF Testray Plugin. \" +\n                \"This method is executed before the log files are persisted\");\n\n        for (TestFeatureLogCollection featureLogCollection : logCollection.getTestFeatureLogCollections()) {\n            System.out.println(\"FEATURE: \" + featureLogCollection.getFeatureName());\n\n            for (TestScenarioLogCollection scenarioLogCollection : featureLogCollection.getScenarioLogCollection()) {\n                System.out.println(\"SCENARIO: \" + scenarioLogCollection.getScenarioName());\n\n                for (LogMessage logMessage : scenarioLogCollection.getLogMessages()) {\n                    System.out.println(\"LOG MESSAGE: \" + logMessage.getMessage());\n                }\n            }\n        }\n    }\n</code></pre> 9. now you can install the new module locally with the command <code>mvn clean install</code>. You can use a temporary version number such as <code>LOCAL_2023_01_01-001</code> for the local version. You can find more information on this in this article. 10. now integrate the new module into a test project via the POM file. The dependency for our example module would look like this:</p> <p><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n    &lt;artifactId&gt;qtaf-testray-plugin&lt;/artifactId&gt;\n    &lt;version&gt;0.0.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> 11. then execute the <code>TestRunner</code> class in your test project. You will see that our new module now generates an output on the console. </p>"},{"location":"sections/plugins/testRail/TestRail_Plugin/","title":"QTAF TestRail Plugin","text":"<p>One possibility to export and document test results is TestRail. In this article we show you how to integrate QTAF in TestRail, how to link your test cases written in Java with the test cases defined in TestRail and how QTAF can automatically save the test results of your test runs in Xray.</p>"},{"location":"sections/plugins/testRail/TestRail_Plugin/#configuration","title":"Configuration","text":"<p>TestRail's API is employed to integrate automated tests and submit the results of the implemented test cases. This API operates on an HTTP basis and can be leveraged using any framework or programming language. The TestRail QTAF Plugin is implemented in Java.</p> <p>In this article, we'll guide you on creating test runs in TestRail, linking your test runs to the test cases specified in TestRail, and how QTAF can automatically record the test results of your runs in TestRail.</p> <p>More Details of using the TestRail API see TestRail API Manual </p>"},{"location":"sections/plugins/testRail/TestRail_Plugin/#creating-test-runs-in-testrail","title":"Creating Test Runs in TestRail","text":"<p>Assuming you've already outlined some test cases in TestRail (note: creating a test case in TestRail isn't covered in this tutorial. For instructions on that, refer to the following video: TestRail's Test Cases),  to craft a test run, navigate to the \"TEST RUNS &amp; RESULTS\" tab, select \"Add Test Run\", and pick the corresponding test suite.</p> <p></p> <p>After creating the test run, you should append the test cases to it. There are three methods to achieve this:</p> <p></p>"},{"location":"sections/plugins/testRail/TestRail_Plugin/#qtaf-and-testrail-integration","title":"QTAF and TestRail Integration","text":"<p>This section shows how the results, attachments and report could be sent to TestRail.</p> <p>This segment illustrates how to transmit results, attachments, and reports to TestRail.</p> <p>Firstly, besides <code>qtaf-core</code>, you need to integrate the <code>qtaf-testrail-plugin</code> dependency into your project. Ensure you have the most recent version numbers of these modules, which can be verified at the Maven Repository</p> <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n        &lt;artifactId&gt;qtaf-core&lt;/artifactId&gt;\n        &lt;version&gt;${qtafVersion}&lt;/version&gt;\n        &lt;scope&gt;compile&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n        &lt;artifactId&gt;qtaf-testrail-plugin&lt;/artifactId&gt;\n        &lt;version&gt;${qtafVersion}&lt;/version&gt;\n        &lt;scope&gt;compile&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>Next, you need to store TestRail credentials within the <code>qtaf.json</code> file. Insert the following section into the file:</p> <pre><code>{\n  ...\n  \"testrail\": {\n    \"enabled\": true,\n    \"url\": \"xxxxxxxx\",\n    \"projectId\": \"xxxxx\",\n    \"authentication\": {\n      \"clientId\": \"xxx@xxx.xxx\",\n      \"clientSecret\": \"xxxxxxxxxx\"\n    }\n  }\n  ...\n}\n</code></pre> <p>Following describes the keys and values of the TestRail configuration section: | Key          | Description                                                                                             | |--------------|---------------------------------------------------------------------------------------------------------| | enabled      | Remember to activate the TestRail Plugin by toggling the  <code>enabled</code> flag.                               | | url          | The HTTP Url to the TestRail server instance.                                                           | | projectId    | The TestRail internal projectID, if it is necessary. You also can define it in the TestRail annotation. | | clientId     | The login credential of the TestRail API.                                                               | | clientSecret | The password credential of the TestRail API.                                                            |</p> <p>After setting up TestRail and saving the credentials, utilize the TestRail annotation to mark the test case. Below is an illustrative example:</p> <pre><code>import de.qytera.qtaf.testrail.annotations.TestRail;\n\n@TestFeature(\n        name = \"DoGoogleSearch\",\n        description = \"Perform a search for text 'Hello World'\"\n)\npublic class DoGoogleSearch extends TestContext {\n    @Test(\n            testName = \"TestGoogleSearch\",\n            description = \"Type 'Hello World' and click search button\",\n            groups = {\"Group 1\", \"Group 2\"}\n    )\n    @TestRail(caseId = {\"11111\"}, runId = \"1111\")\n    public void TestCaseGoogleSearch()\n    {\n        // test logic here\n    }\n}\n</code></pre> <p>To map a test class to a test in TestRail, apply the <code>@TestRail</code> annotation to the appropriate Java method. The <code>caseId</code> and <code>runId</code> attributes of the annotation should match the test case ID and test run ID in TestRail.</p> <p>Images are provided to guide you in locating the test case ID and test run ID.</p> <ul> <li>To get the test run ID, click on \"TEST RUNS &amp; RESULTS\" tab, choose your test run, top in the left corner you can find the ID, it is framed with black in the following image:</li> </ul> <p></p> <ul> <li>To get the test case ID, click on \"TEST SUITES &amp; CASES\" tab, choose your test suite, then you test case, top in the left corner you can find the ID, it is framed with black in the following image:</li> </ul> <p></p> <p>In order to also document the test steps, methods must be called in the test that are provided with the annotation <code>@Step</code> of the QTAF framework. In this example, we assume that there are two methods that are defined in a separate class called <code>GoogleFunctionsPage</code>.</p> <pre><code>public class GoogleFunctions extends TestContext\n{\n    @Step(\n            name = \"Search value\",\n            description = \"Search for a value\"\n    )\n    public void doSearch(String searchValue) {\n        driver.findElement(By.xpath(UsedObject.SearchInputXPath())).sendKeys(searchValue);\n        driver.findElement(By.name(UsedObject.GoogleSearchButtonName())).click();\n    }\n\n    @Step(\n            name = \"Go to Google home page\",\n            description = \"Navigate to the Google home page\"\n    )\n    public void goToGoogleHome() {\n        driver.get(UsedObject.GoogleHome());\n    }\n}\n</code></pre> <p>We then call these methods in the test case.</p> <pre><code>@TestFeature(\n        name = \"DoGoogleSearch\",\n        description = \"Perform a search for text 'Hello World'\"\n)\npublic class DoGoogleSearch extends TestContext\n{\n    @Test(\n            testName = \"TestGoogleSearch\",\n            description = \"Type 'Hello World' and click search button\",\n            groups = {\"Group 1\", \"Group 2\"}\n    )\n    @TestRail(caseId = {\"11111\"}, runId = \"1111\")\n    public void TestCaseGoogleSearch()\n    {\n         // 1. Open Google\n        googleFunctionPage.goToGoogleHome();\n\n        // 2. Execute Search\n        googleFunctionPage.doSearch(\"Hello World\");\n    }\n}\n</code></pre> <p>QTAF registers the call of these methods and logs the call in the background. Here, no IDs need to be defined for the test steps. QTAF assigns the called methods in the order of the steps defined in TestRail.</p> <p>Now execute your test cases as usual. After the execution of your test cases is finished, QTAF will show you the following statement in the console:</p> <pre><code>INFO  de.qytera.qtaf.core - Results are uploaded to testRail\n</code></pre> <p>This means that the upload to TestRail was successful.</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/plugins/xray/Configuration/","title":"Configuration","text":"<p>All Xray plugin options can be specified within the <code>xray</code> property of the configuration JSON.</p> <p>Note</p> <p>The following icons describe whether the individual settings apply to Xray server or Xray cloud only:</p> <ul> <li> Setting applicable to/relevant for Xray cloud only</li> <li> Setting applicable to/relevant for Xray server only</li> </ul> <p>All settings without such icons are applicable to both versions.</p>"},{"location":"sections/plugins/xray/Configuration/#authentication","title":"<code>authentication</code>","text":"<p>In order to upload results to Xray, QTAF needs to authenticate to it.</p> <p>Tip</p> <p>Have a look at this graph to quickly set up Xray and Jira authentication. <pre><code>graph LR\n    A{Xray&lt;br/&gt;instance};\n    B(\"xray.clientId=&lt;i&gt;id&lt;/i&gt;&lt;br&gt;xray.clientSecret=&lt;i&gt;secret&lt;/i&gt;&lt;br&gt;&lt;hr&gt;jira.username=&lt;i&gt;user@company.com&lt;/i&gt;&lt;br&gt;jira.apiToken=&lt;i&gt;token&lt;/i&gt;\");\n    A ----&gt;|&amp;nbsp cloud &amp;nbsp| B;\n    A ----&gt;|&amp;nbsp server &amp;nbsp| D;\n    D(\"xray.bearerToken=&lt;i&gt;token&lt;/i&gt;&lt;br&gt;&lt;hr&gt;jira.apiToken=&lt;i&gt;token&lt;/i&gt;\");\n    classDef code-node text-align:left;\n    class B,D,E code-node;</code></pre></p> <p>Please note that basic authentication for Xray server and Jira server is not supported by QTAF.</p>"},{"location":"sections/plugins/xray/Configuration/#xray","title":"<code>xray</code>","text":"<p>Xray server or Xray cloud credentials can be specified here.</p> <p>Note</p> <p>Consult Xray's official documentation on how to set up:</p> <ul> <li> Cloud API keys</li> <li> Server tokens</li> </ul>"},{"location":"sections/plugins/xray/Configuration/#bearertoken","title":"<code>bearerToken</code>","text":"<p>The Jira PAT of the user QTAF should use for interacting with Xray.</p> Environment variable <code>XRAY_AUTHENTICATION_XRAY_BEARERTOKEN</code> Type <code>string</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"authentication\": {\n    \"xray\": {\n      \"bearerToken\": \"BigSecretToken\"\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_AUTHENTICATION_XRAY_BEARERTOKEN=\"BigSecretToken\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#clientid","title":"<code>clientId</code>","text":"<p>The ID of the user all requests will be done in behalf of.</p> Environment variable <code>XRAY_AUTHENTICATION_XRAY_CLIENTID</code> Type <code>string</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"authentication\": {\n    \"xray\": {\n      \"clientId\": \"12345ABCDEF\"\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_AUTHENTICATION_XRAY_CLIENTID=\"12345ABCDEF\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#clientsecret","title":"<code>clientSecret</code>","text":"<p>The secret of the user all requests will be done in behalf of.</p> Environment variable <code>XRAY_AUTHENTICATION_XRAY_CLIENTSECRET</code> Type <code>string</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"authentication\": {\n    \"xray\": {\n      \"clientSecret\": \"xyzSuperSecretxyz\"\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_AUTHENTICATION_XRAY_CLIENTSECRET=\"xyzSuperSecretxyz\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#jira","title":"<code>jira</code>","text":"<p>Additional Jira credentials might be necessary too, depending on how you configure the plugin.</p>"},{"location":"sections/plugins/xray/Configuration/#username","title":"<code>username</code>","text":"<p>The username for Jira Cloud authentication. It is usually the Email address of the user, as described here.</p> Environment variable <code>XRAY_AUTHENTICATION_JIRA_USERNAME</code> Type <code>string</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"authentication\": {\n    \"jira\": {\n      \"username\": \"fred@example.com\"\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_AUTHENTICATION_JIRA_USERNAME=\"fred@example.com\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#apitoken","title":"<code>apiToken</code>","text":"<p>The API token granting access to the API of the Jira instance. More information:</p> <ul> <li> Xray documentation</li> <li> Xray documentation</li> </ul> Environment variable <code>XRAY_AUTHENTICATION_JIRA_APITOKEN</code> Type <code>string</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"authentication\": {\n    \"jira\": {\n      \"apiToken\": \"MyLittleJiraSecret\"\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_AUTHENTICATION_JIRA_APITOKEN=\"MyLittleJiraSecret\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#enabled","title":"<code>enabled</code>","text":"<p>Enables or disables the plugin entirely. If set to <code>false</code>, the plugin will be skipped completely and no results will be uploaded.</p> Environment variable <code>XRAY_ENABLED</code> Type <code>boolean</code> <p>Accepted strings (case-insensitive):</p> <ul> <li> <p><code>\"true\"</code> <code>\"1\"</code> <code>\"y\"</code></p> </li> <li> <p><code>\"false\"</code> <code>\"0\"</code> <code>\"n\"</code></p> </li> </ul> Default <code>false</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"enabled\": \"y\"\n}\n</code></pre> <pre><code>XRAY_ENABLED=\"y\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#projectkey","title":"<code>projectKey</code>","text":"<p>The Jira key of the project to upload results to. It is used for identification of relevant test cases, meaning that only test cases with an <code>@XrayTest</code> annotation containing the project key will be tracked and eventually uploaded to Xray.</p> Environment variable <code>XRAY_PROJECTKEY</code> Type <code>string</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"projectKey\": \"PRJ\"\n}\n</code></pre> <pre><code>XRAY_PROJECTKEY=\"PRJ\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#resultsupload","title":"<code>resultsUpload</code>","text":"<p>These settings determine the plugin's behaviour regarding the results upload.</p>"},{"location":"sections/plugins/xray/Configuration/#assignee","title":"<code>assignee</code>","text":"<p>The Jira user to assign created test executions to. The following values should be provided here:</p> <ul> <li> The account ID, usually of the form <code>61f8f589e688d6007068a792</code>.   You can retrieve account IDs by exporting an issue as XML where the user is visible (reporter, assignee, ...). The XML element containing the account ID will then look something like this:   <pre><code>&lt;assignee accountid=\"61f8f589e688d6007068a792\"&gt;John Miller&lt;/assignee&gt;\n</code></pre></li> <li> The username used for login, for example <code>miller_j</code>.   You can retrieve usernames of other users by exporting an issue as XML where the user is visible (reporter, assignee, ...). The XML element will then look something like this:   <pre><code>&lt;assignee&gt;miller_j&lt;/assignee&gt;\n</code></pre></li> </ul> <p>Note</p> <p>If the configured assignee is <code>null</code>, the test execution issues will not be assigned to anyone.</p> Environment variable <code>XRAY_RESULTSUPLOAD_ASSIGNEE</code> Type <code>string</code> Default <code>null</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"assignee\": \"61f8f589e688d6007068a792\"\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_ASSIGNEE=\"61f8f589e688d6007068a792\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#customstatus","title":"<code>customStatus</code>","text":"<p>These status settings map QTAF test (execution) statuses to corresponding Jira issue or Xray test and step statuses.</p>"},{"location":"sections/plugins/xray/Configuration/#step","title":"<code>step</code>","text":"<p>These settings allow mapping QTAF test steps to Xray step statuses.</p> <p>Tip</p> <p>If you have custom step statuses set up in Xray, you should provide their names here.</p>"},{"location":"sections/plugins/xray/Configuration/#failed","title":"<code>failed</code>","text":"<p>The Xray status of failed steps.</p> Environment variable <code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_STEP_FAILED</code> Type <code>string</code> Default <code>\"FAIL\"</code> <code>\"FAILED\"</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"customStatus\": {\n      \"step\": {\n        \"failed\": \"ERROR\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_STEP_FAILED=\"ERROR\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#passed","title":"<code>passed</code>","text":"<p>The Xray status of passed steps.</p> Environment variable <code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_STEP_PASSED</code> Type <code>string</code> Default <code>\"PASS\"</code> <code>\"PASSED\"</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"customStatus\": {\n      \"step\": {\n        \"passed\": \"DONE\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_STEP_PASSED=\"DONE\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#pending","title":"<code>pending</code>","text":"<p>The Xray status of pending steps.</p> Environment variable <code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_STEP_PENDING</code> Type <code>string</code> Default <code>\"EXECUTING\"</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"customStatus\": {\n      \"step\": {\n        \"pending\": \"EXECUTING\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_STEP_PENDING=\"EXECUTING\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#skipped","title":"<code>skipped</code>","text":"<p>The Xray status of skipped steps.</p> Environment variable <code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_STEP_SKIPPED</code> Type <code>string</code> Default <code>\"TODO\"</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"customStatus\": {\n      \"step\": {\n        \"skipped\": \"TODO\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_STEP_SKIPPED=\"TODO\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#test","title":"<code>test</code>","text":"<p>These settings allow mapping QTAF test statuses to Xray statuses, for example when setting the status of a test inside a test test execution issue.</p> <p>Tip</p> <p>If you have custom statuses set up in Xray, you should provide their names here.</p>"},{"location":"sections/plugins/xray/Configuration/#failed_1","title":"<code>failed</code>","text":"<p>The Xray status of failed tests.</p> Environment variable <code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_TEST_FAILED</code> Type <code>string</code> Default <code>\"FAIL\"</code> <code>\"FAILED\"</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"customStatus\": {\n      \"test\": {\n        \"failed\": \"ERROR\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_TEST_FAILED=\"ERROR\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#passed_1","title":"<code>passed</code>","text":"<p>The Xray status of passed tests.</p> Environment variable <code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_TEST_PASSED</code> Type <code>string</code> Default <code>\"PASS\"</code> <code>\"PASSED\"</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"customStatus\": {\n      \"test\": {\n        \"passed\": \"DONE\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_TEST_PASSED=\"DONE\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#pending_1","title":"<code>pending</code>","text":"<p>The Xray status of pending tests.</p> Environment variable <code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_TEST_PENDING</code> Type <code>string</code> Default <code>\"EXECUTING\"</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"customStatus\": {\n      \"test\": {\n        \"pending\": \"EXECUTING\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_TEST_PENDING=\"EXECUTING\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#skipped_1","title":"<code>skipped</code>","text":"<p>The Xray status of skipped tests.</p> Environment variable <code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_TEST_SKIPPED</code> Type <code>string</code> Default <code>\"TODO\"</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"customStatus\": {\n      \"test\": {\n        \"skipped\": \"TODO\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_TEST_SKIPPED=\"TODO\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#testexecutionissue","title":"<code>testExecutionIssue</code>","text":"<p>The Jira status of test execution issues created during upload.</p>"},{"location":"sections/plugins/xray/Configuration/#failed_2","title":"<code>failed</code>","text":"<p>The Jira status to transition test execution issues to if tests failed. If the status is <code>null</code>, the issue will have the default issue status of issues created in the project.</p> Environment variable <code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_TESTEXECUTIONISSUE_FAILED</code> Type <code>string</code> Default <code>null</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"customStatus\": {\n      \"testExecutionIssue\": {\n        \"failed\": \"Review\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_TESTEXECUTIONISSUE_FAILED=\"Review\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#passed_2","title":"<code>passed</code>","text":"<p>The Jira status to transition test execution issues to if all tests passed. If the status is <code>null</code>, the issue will have the default issue status of issues created in the project.</p> Environment variable <code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_TESTEXECUTIONISSUE_PASSED</code> Type <code>string</code> Default <code>null</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"customStatus\": {\n      \"testExecutionIssue\": {\n        \"passed\": \"Done\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_CUSTOMSTATUS_TESTEXECUTIONISSUE_PASSED=\"Done\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#environments","title":"<code>environments</code>","text":"<p>QTAF can add test environments to created test execution issues. The following settings can be used to control the way QTAF assigns test environments.</p> <p>Info</p> <p>For more information about test environments, please see:</p> <ul> <li> Xray documentation</li> <li> Xray documentation</li> </ul>"},{"location":"sections/plugins/xray/Configuration/#driver","title":"<code>driver</code>","text":"<p>Toggles whether QTAF should add the name of the Selenium driver used to execute the tests as test environment.</p> Environment variable <code>XRAY_RESULTSUPLOAD_ENVIRONMENTS_DRIVER</code> Type <code>boolean</code> <p>Accepted strings (case-insensitive):</p> <ul> <li> <p><code>\"true\"</code> <code>\"1\"</code> <code>\"y\"</code></p> </li> <li> <p><code>\"false\"</code> <code>\"0\"</code> <code>\"n\"</code></p> </li> </ul> Default <code>true</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"environments\": {\n      \"driver\": false\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_ENVIRONMENTS_DRIVER=\"false\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#enabled_1","title":"<code>enabled</code>","text":"<p>Toggles whether QTAF should include test environments during test execution issue creation. Setting this option to <code>false</code> will result in no test environments being added to the test execution issue.</p> Environment variable <code>XRAY_RESULTSUPLOAD_ENVIRONMENTS_ENABLED</code> Type <code>boolean</code> <p>Accepted strings (case-insensitive):</p> <ul> <li> <p><code>\"true\"</code> <code>\"1\"</code> <code>\"y\"</code></p> </li> <li> <p><code>\"false\"</code> <code>\"0\"</code> <code>\"n\"</code></p> </li> </ul> Default <code>true</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"environments\": {\n      \"enabled\": false\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_ENVIRONMENTS_ENABLED=\"n\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#os","title":"<code>os</code>","text":"<p>Toggles whether QTAF should add the name of the operating system the tests were executed on as test environment.</p> Environment variable <code>XRAY_RESULTSUPLOAD_ENVIRONMENTS_OS</code> Type <code>boolean</code> <p>Accepted strings (case-insensitive):</p> <ul> <li> <p><code>\"true\"</code> <code>\"1\"</code> <code>\"y\"</code></p> </li> <li> <p><code>\"false\"</code> <code>\"0\"</code> <code>\"n\"</code></p> </li> </ul> Default <code>true</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"environments\": {\n      \"os\": false\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_ENVIRONMENTS_OS=\"0\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#scenarioimageevidence","title":"<code>scenarioImageEvidence</code>","text":"<p>Toggles whether QTAF should attach screenshot evidence to the test execution issue. Setting this to <code>true</code> will result in QTAF adding all screenshots it takes during a test to the test case inside the test execution.</p> <p>Info</p> <p>For more information about test execution evidence, please see:</p> <ul> <li> Xray documentation</li> <li> Xray documentation</li> </ul> Environment variable <code>XRAY_RESULTSUPLOAD_SCENARIOIMAGEEVIDENCE</code> Type <code>boolean</code> <p>Accepted strings (case-insensitive):</p> <ul> <li> <p><code>\"true\"</code> <code>\"1\"</code> <code>\"y\"</code></p> </li> <li> <p><code>\"false\"</code> <code>\"0\"</code> <code>\"n\"</code></p> </li> </ul> Default <code>false</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"scenarioImageEvidence\": true\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_SCENARIOIMAGEEVIDENCE=\"y\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#scenarioreportevidence","title":"<code>scenarioReportEvidence</code>","text":"<p>Toggles whether QTAF should attach the HTML report it generates as evidence to the test execution issue.</p> <p>Info</p> <p>For more information about test execution evidence, please see:</p> <ul> <li> Xray documentation</li> <li> Xray documentation</li> </ul> Environment variable <code>XRAY_RESULTSUPLOAD_SCENARIOREPORTEVIDENCE</code> Type <code>boolean</code> <p>Accepted strings (case-insensitive):</p> <ul> <li> <p><code>\"true\"</code> <code>\"1\"</code> <code>\"y\"</code></p> </li> <li> <p><code>\"false\"</code> <code>\"0\"</code> <code>\"n\"</code></p> </li> </ul> Default <code>false</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"scenarioReportEvidence\": true\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_SCENARIOREPORTEVIDENCE=\"1\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#testplankey","title":"<code>testPlanKey</code>","text":"<p>Test executions can automatically be assigned to an existing test plan. QTAF uses this setting to retrieve such configured test plans. When set to <code>null</code>, QTAF will not add created test execution issues to any test plan.</p> Environment variable <code>XRAY_RESULTSUPLOAD_TESTPLANKEY</code> Type <code>string</code> Default <code>null</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"testPlanKey\": \"PRJ-123\"\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_TESTPLANKEY=\"PRJ-123\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#tests","title":"<code>tests</code>","text":"<p>The settings below allow configuring the way test cases themselves are updated during test results upload.</p>"},{"location":"sections/plugins/xray/Configuration/#iterations","title":"<code>iterations</code>","text":"<p>When uploading data-driven test results, QTAF will automatically use Xray's iterations in test executions. Settings related to these iterations are listed here.</p>"},{"location":"sections/plugins/xray/Configuration/#parameters","title":"<code>parameters</code>","text":"<p>Xray can add parameters to data-driven test iteration results, which provide information about the names and values of the concrete test case parameters. Parameter settings are listed here.</p> <p>Info</p> <p>For more information about iteration parameters, please see:</p> <ul> <li> Xray documentation</li> <li> Xray documentation</li> </ul>"},{"location":"sections/plugins/xray/Configuration/#maxlength","title":"<code>maxLength</code>","text":"<p>Xray enforces a hard limit on the length of both parameter names and values, which is different for Xray cloud and Xray server and from version to version. It is recommended to provide reasonable values like <code>30</code> here for both <code>name</code> and <code>value</code> to keep things readable and to prevent Xray from rejecting test result uploads altogether. QTAF will automatically truncate parameter names and values of the iterations to the numbers provided here.</p> <p>Warning</p> <p>If set to <code>null</code>, QTAF will not truncate parameter names or values whatsoever, possibly resulting in failed result uploads. Make sure to manually identify the limit your Xray instance is enforcing through the UI!</p> Environment variables <code>XRAY_RESULTSUPLOAD_TESTS_ITERATIONS_PARAMETERS_MAXLENGTH_NAME</code> <code>XRAY_RESULTSUPLOAD_TESTS_ITERATIONS_PARAMETERS_MAXLENGTH_VALUE</code> Type <code>number</code> Default <code>null</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"tests\": {\n      \"iterations\": {\n        \"parameters\": {\n          \"maxLength\": {\n            \"name\": 42,\n            \"value\": 50\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_TESTS_ITERATIONS_PARAMETERS_MAXLENGTH_NAME=42\nXRAY_RESULTSUPLOAD_TESTS_ITERATIONS_PARAMETERS_MAXLENGTH_VALUE=50\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#info","title":"<code>info</code>","text":"<p>Settings regarding general test case information.</p>"},{"location":"sections/plugins/xray/Configuration/#keepjirasummary","title":"<code>keepJiraSummary</code>","text":"<p>When uploading test results, QTAF can automatically rename existing test issues to the test case's name defined within QTAF. This setting toggles whether this is allowed to happen or whether the test case's existing summaries should be kept.</p> Environment variable <code>XRAY_RESULTSUPLOAD_TESTS_INFO_KEEPJIRASUMMARY</code> Type <code>boolean</code> <p>Accepted strings (case-insensitive):</p> <ul> <li> <p><code>\"true\"</code> <code>\"1\"</code> <code>\"y\"</code></p> </li> <li> <p><code>\"false\"</code> <code>\"0\"</code> <code>\"n\"</code></p> </li> </ul> Default <code>false</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"tests\": {\n      \"info\": {\n        \"keepJiraSummary\": true\n      }\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_TESTS_INFO_KEEPJIRASUMMARY=\"y\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#steps","title":"<code>steps</code>","text":"<p>When uploading test results, QTAF can automatically update or change the steps defined within existing test issues with the steps it executed itself. These settings control how and whether this is allowed to happen.</p>"},{"location":"sections/plugins/xray/Configuration/#update","title":"<code>update</code>","text":"<p>Toggles whether QTAF is allowed to update existing test issue steps in Xray. Setting this to <code>true</code> will result in QTAF replacing all existing steps with the ones it executed itself. To not modify any existing steps, set this to <code>false</code>.</p> Environment variable <code>XRAY_RESULTSUPLOAD_TESTS_INFO_STEPS_UPDATE</code> Type <code>boolean</code> <p>Accepted strings (case-insensitive):</p> <ul> <li> <p><code>\"true\"</code> <code>\"1\"</code> <code>\"y\"</code></p> </li> <li> <p><code>\"false\"</code> <code>\"0\"</code> <code>\"n\"</code></p> </li> </ul> Default <code>false</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"tests\": {\n      \"info\": {\n        \"steps\": {\n          \"update\": true\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_TESTS_INFO_STEPS_UPDATE=\"true\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#merge","title":"<code>merge</code>","text":"<p>Toggles whether QTAF should merge all steps it executed into a single step before updating test case steps in Xray. The merged step will then contain a list of steps, possibly for all test case iterations if a test was executed more than once:</p> <p><pre><code># Step 1 (the only remaining step)\n  == ITERATION 1 username=\"denise\" password=\"xyz12\" address=\"main avenue\"\n    1. Click register\n    2. Enter username\n    3. Enter password\n    4. Enter address\n    5. Click submit\n  == ITERATION 2 username=\"george\" password=\"12345\" address=\"\"\n    1. Click register\n    2. Enter username\n    3. Enter password\n    4. Click submit\n</code></pre> In situations like above where individual test runs might not always consist of exactly the same steps (for example when skipping empty form fields), Xray would not be able to properly display the test results inside the test execution issue without the merged steps:</p> Steps defined in test case issue Steps reported in test execution (iteration 1) Steps reported in test execution (iteration 2) Problem <ol> <li>Click register</li> <li>Enter username</li> <li>Enter password</li> <li>Click submit</li> </ol> <ol> <li>Click register</li> <li>Enter username</li> <li>Enter password</li> <li>Enter address</li> </ol> <ol> <li>Click register</li> <li>Enter username</li> <li>Enter password</li> <li>Click submit</li> </ol> Fifth step truncated in iteration 1 by Xray. <ol> <li>Click register</li> <li>Enter username</li> <li>Enter password</li> <li>Enter address</li> <li>Click submit</li> </ol> <ol> <li>Click register</li> <li>Enter username</li> <li>Enter password</li> <li>Enter address</li> <li>Click submit</li> </ol> <ol> <li>Click register</li> <li>Enter username</li> <li>Enter password</li> <li>Enter address</li> <li>Click submit</li> </ol> Mismatched steps in interation 2: the address was never actually entered and Xray marked the fifth step as TODO because only four steps were actually executed in iteration 2. <p>Merging the iterations' steps can therefore help for data-driven testing.</p> Environment variable <code>XRAY_RESULTSUPLOAD_TESTS_INFO_STEPS_MERGE</code> Type <code>boolean</code> <p>Accepted strings (case-insensitive):</p> <ul> <li> <p><code>\"true\"</code> <code>\"1\"</code> <code>\"y\"</code></p> </li> <li> <p><code>\"false\"</code> <code>\"0\"</code> <code>\"n\"</code></p> </li> </ul> Default <code>false</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"resultsUpload\": {\n    \"tests\": {\n      \"info\": {\n        \"steps\": {\n          \"merge\": true\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>XRAY_RESULTSUPLOAD_TESTS_INFO_STEPS_MERGE=\"true\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#service","title":"<code>service</code>","text":"<p>Defines whether the targeted Xray instance is an Xray cloud or Xray server instance. QTAF requires this setting because Xray's APIs need to be addressed slightly differently.</p> Environment variable <code>XRAY_SERVICE</code> Type <code>\"cloud\"</code> or <code>\"server\"</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"service\": \"server\"\n}\n</code></pre> <pre><code>XRAY_SERVICE=\"server\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#url","title":"<code>url</code>","text":"<p>To properly connect to Xray, QTAF needs to know where the Xray and Jira instances can be found.</p>"},{"location":"sections/plugins/xray/Configuration/#jira_1","title":"<code>jira</code>","text":"<p>Defines the base URL of the Jira instance. For Jira cloud, it is usually of the form <code>https://your-domain.atlassian.net</code> (without the <code>/jira</code> part, see here). For Jira server, you can have a look here to determine your base URL.</p> Environment variable <code>XRAY_URL_JIRA</code> Type <code>string</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"url\": {\n    \"jira\": \"https://example.org/development/jira\"\n  }\n}\n</code></pre> <pre><code>XRAY_URL_JIRA=\"https://example.org/development/jira\"\n</code></pre>"},{"location":"sections/plugins/xray/Configuration/#xray_1","title":"<code>xray</code>","text":"<p>Defines the base URL of the Xray instance.</p> Environment variable <code>XRAY_URL_XRAY</code> Type <code>string</code> Example QTAF JSONEnvironment variable <pre><code>\"xray\": {\n  \"url\": {\n    \"xray\": \"https://xray.jira.company.com\"\n  }\n}\n</code></pre> <pre><code>XRAY_URL_XRAY=\"https://xray.jira.company.com\"\n</code></pre> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/plugins/xray/XRAY_Plugin/","title":"QTAF Xray Plugin","text":"<p>One possibility to export and document test results is Xray for Jira. In this article we show you how to create test cases in Xray, how to link your test cases written in Java with the test cases defined in Xray and how QTAF can automatically save the test results of your test runs in Xray.</p>"},{"location":"sections/plugins/xray/XRAY_Plugin/#create-test-cases-in-xray","title":"Create test cases in Xray","text":"<p>The first step is to create the definitions of our test cases in Xray. In our example, we will create three test case definitions called <code>QTAF-1</code>, <code>QTAF-2</code> and <code>QTAF-3</code>.</p> <p>First you have to click on \"Testing Board\" in the left menu of Jira to get to the user interface of Xray. The following screenshot shows the testing board of our example project. Create the three test case definitions for our test cases here.</p> <p></p> <p>Test steps must still be defined for each of the three tests. In the Xray user interface, these can be found in the \"Test Details\" section. In our example, we assume that the tests <code>QTAF-1</code>, <code>QTAF-2</code> and <code>QTAF-3</code> have two, three and two steps respectively. The following picture shows the test case <code>QTAF-1</code> in Xray:</p> <p></p> <p>If you're using Qtaf with Xray, the test environment may be missing on Xray. In such cases, you need to configure the required test environment. Refer to this link for more details.</p>"},{"location":"sections/plugins/xray/XRAY_Plugin/#qtaf-and-xray","title":"QTAF and Xray","text":"<p>This section shows how the recorded information about the executed test cases and test steps can be automatically sent to Xray.</p> <p>In addition to <code>qtaf-core</code>, first integrate the dependency <code>qtaf-xray-plugin</code> into your project: Make sure that you use the current version numbers of these modules. You can find them at the Maven Repository</p> <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n        &lt;artifactId&gt;qtaf-core&lt;/artifactId&gt;\n        &lt;version&gt;${qtafVersion}&lt;/version&gt;\n        &lt;scope&gt;compile&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n        &lt;artifactId&gt;qtaf-xray-plugin&lt;/artifactId&gt;\n        &lt;version&gt;${qtafVersion}&lt;/version&gt;\n        &lt;scope&gt;compile&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>Next we have to store the credentials for Xray in the <code>configuration.json</code> file. To do this, add the following section to this file:</p> <pre><code>{\n  ...\n  \"xray\":{\n    \"enabled\": true,\n    \"authentication\":{\n      \"clientId\": \"&lt;YOUR_CLIENT_ID&gt;\",\n      \"clientSecret\": \"&lt;YOUR_CLIENT_SECRET&gt;\"\n    }\n  },\n  ...\n}\n</code></pre> <p>Then create three test cases and annotate each with all required annotations. To assign a test class to a test in Xray the annotation <code>@XrayTest</code> must be set for the respective Java method and the attribute <code>key</code> of the annotation must correspond to the key of the test in Xray. The following example shows a test whose results are to be stored in Xray under issua <code>QTAF-1</code>.</p> <pre><code>import de.qytera.qtaf.xray.annotation.XrayTest;\n\n@TestFeature(\n        name = \"DoGoogleSearch\",\n        description = \"Perform a search for text 'Hello World'\"\n)\npublic class DoGoogleSearch extends TestContext {\n    @Test(\n            testName = \"TestGoogleSearch\",\n            description = \"Type 'Hello World' and click search button\",\n            groups = {\"Group 1\", \"Group 2\"}\n    )\n    @XrayTest(key = \"QTAF-1\")\n    public void TestCaseGoogleSearch()\n    {\n        // test logic here\n    }\n}\n</code></pre> <p>In order to also document the test steps, methods must be called in the test that are provided with the annotation <code>@Step</code> of the Qtaf framework. In this example, we assume that there are two methods that are defined in a separate class called <code>GoogleFunctionsPage</code>.</p> <pre><code>public class GoogleFunctions extends TestContext\n{\n    @Step(\n            name = \"Search value\",\n            description = \"Search for a value\"\n    )\n    public void doSearch(String searchValue) {\n        driver.findElement(By.xpath(UsedObject.SearchInputXPath())).sendKeys(searchValue);\n        driver.findElement(By.name(UsedObject.GoogleSearchButtonName())).click();\n    }\n\n    @Step(\n            name = \"Go to Google home page\",\n            description = \"Navigate to the Google home page\"\n    )\n    public void goToGoogleHome() {\n        driver.get(UsedObject.GoogleHome());\n    }\n}\n</code></pre> <p>We then call these methods in the test case.</p> <pre><code>@TestFeature(\n        name = \"DoGoogleSearch\",\n        description = \"Perform a search for text 'Hello World'\"\n)\npublic class DoGoogleSearch extends TestContext\n{\n    @Test(\n            testName = \"TestGoogleSearch\",\n            description = \"Type 'Hello World' and click search button\",\n            groups = {\"Group 1\", \"Group 2\"}\n    )\n    @XrayTest(key = \"QTAF-1\")\n    public void TestCaseGoogleSearch()\n    {\n         // 1. Open Google\n        googleFunctionPage.goToGoogleHome();\n\n        // 2. Execute Search\n        googleFunctionPage.doSearch(\"Hello World\");\n    }\n}\n</code></pre> <p>QTAF registers the call of these methods and logs the call in the background. Here, no IDs need to be defined for the test steps. QTAF assigns the called methods in the order of the steps defined in Xray.</p> <p>Now execute your test cases as usual. After the execution of your test cases is finished, QTAF will show you the following statement in the console:</p> <pre><code>15:22:25.717 [main] INFO  de.qytera.qtaf.core - Uploading Xray results ...\n15:22:49.260 [main] INFO  de.qytera.qtaf.core - Uploaded test execution. Key is QTAF-846\n</code></pre> <p>This means that the upload to Xray was successful and can now be viewed in Jira under the key \"QTAF-846\".</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/setup/IntelliJ_Project_Setup/","title":"Setup new QTAF Project with IntelliJ and Maven","text":"<p>Before you read this article you should be familiar with the QTAF framework. You can read this article if you want to understand the Java code which is shown here.</p> <p>To create a new project, we use the IntelliJ IDE from Jetbrains. Here we navigate in the menu to <code>File &gt; New &gt; Project</code> and then select <code>Maven</code> in the left selection menu and click on Next.</p> <p></p> <p>We are then asked for a name for the project. This can be chosen freely, but in this example we use the name \"QtafProject\". It is recommended to also specify the GroupId of the project. This is an identifier for the creator of the project. It is common to choose the company's domain for this, but starting with the country- or organisation-specific ending of the domain. For a company domain \"acme.org\", one would choose the GroupId \"org.acme\" according to this standard. The GroupId can be found in the sub-item <code>Artifact Coordinates</code>. Then we click on <code>Finish</code>. The new project should now have been created in the folder <code>~\\IdeaProjects\\QtafProject</code>, where <code>~</code> is a placeholder for the root directory of the currently logged in user.</p> <p></p> <p>In the root directory of the project we see the file pom.xml. This file is used to configure Maven projects, i.e. to load external libraries, to control the build process, etc.</p> <p>The following additions should be entered in the file:</p> <pre><code>&lt;project&gt;\n    &lt;!-- ... --&gt;\n\n    &lt;!-- Here we define the Java version of the project --&gt;\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;\n    &lt;/properties&gt;\n\n    &lt;!-- Here you can add external Java libraries to your project --&gt;\n    &lt;dependencies&gt;\n\n    &lt;/dependencies&gt;\n\n    &lt;!-- Everything is configured here for the build process --&gt;\n    &lt;build&gt;\n        &lt;!-- Path under which Java should search for files (resources) --&gt;\n        &lt;resources&gt;\n            &lt;resource&gt;\n                &lt;directory&gt;src/main/resources&lt;/directory&gt;\n                &lt;filtering&gt;true&lt;/filtering&gt;\n            &lt;/resource&gt;\n        &lt;/resources&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/setup/VSCode_Project_Setup/","title":"Setup QTAF in VSCode","text":"<p>Before you read this article you should be familiar with the QTAF framework. You can read this article if you want to understand the Java code which is shown here.</p> <p>Front-end developers mostly use VSCode IDE for developing front-end applications, so it is of great importance that they can also start back-end projects with VSCode.</p> <p>To test the QTAF implementation under VSCode, Java 17 should first be installed on the system, there are several tutorials on this. The following instructions show how to install Java 17 on different operating systems:</p> <p>Install Java 17</p> <p>Now check if the installation was sucecssful with the following command:</p> <pre><code>$ java --version\n</code></pre> <p>Now open VSCode and install the extension \"Extension Pack for Java\".</p>  Your browser does not support the video tag.  <p>Furthermore you need to install the extension \"Maven for Java\".</p>  Your browser does not support the video tag.  <p>After installing the necessary extensions, a view \"JAVA PROJECTS\" with the project structure is activated under Explorer.</p> <p></p> <p>To run tests, the Java Pack Extension adds the button \"Run/Debug\" next to the test classes, as in classic Java IDEs (Eclips or Intellij).</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/steps/Data_Providers/","title":"Data Providers","text":"<p>In this article you will learn how to implement data-driven test scenarios with QTAF.</p> <p>In this tutorial, we will assume a test case that is supposed to fill out a form on a website. This test case could look like the example shown:</p> <pre><code>@TestFeature(\n        name = \"Calls form\",\n        description = \"Create call form\"\n)\npublic class CallsTest extends TestContext {\n    @Test(testName = \"CallsTest\", description = \"Calls Test\")\n    public void testCalls() {\n        //Navigate to calls page\n        navigator.goToRootPage();\n        topNavbar.openMobileMenu();\n        topNavbar.clickMobileCallsMenu();\n        callsPage.clickCallsModuleButton();\n        topBarCallsMenu.clickLogCallLink();\n        // Fill call form\n        createCallForm.fillSubjectField(\"Call subject\");\n        createCallForm.fillDurationField();\n        createCallForm.fillDescriptionField(\"Call description\");\n        createCallPage.clickSaveButton();\n        //Navigate to Home page\n        topNavbar.openMobileMenu();\n        topNavbar.clickHomeMenuFromNotHomePage();\n    }\n}\n</code></pre> <p>In this example, you see a test scenario called <code>CallsTest</code>, which calls various page objects to eventually fill out a form on a website and submit it afterwards. In this example, the page object <code>createCallForm</code> is responsible for filling out the form, which provides the methods <code>fillSubjectField</code> and <code>fillDescriptionField</code>, among others. Both methods accept a string as parameter.</p> <p>In the example shown, the data we want to enter into the form is statically defined, i.e. no parameters can be passed to the test case from outside. However, if we want this test scenario to run multiple times and with different data, we need to make the following changes to our test scenario.</p>"},{"location":"sections/steps/Data_Providers/#creating-a-data-provider","title":"Creating a Data Provider","text":"<p>First, within our Java class, which in our example is called <code>CallsTest</code>, we create a new method called <code>getCallsData</code>. You are free to choose the name of this method. This method returns a two-dimensional array of type <code>Object[][]</code>. Furthermore, this method must be annotated with the annotation <code>@DataProvider</code> of the TestNG framework. Also, assign an ID of this Data Provider using the <code>name</code> attribute in the DataProvider annotation. The DataProvider could look like this:</p> <pre><code>import org.testng.annotations.*;\n\n@TestFeature(\n        name = \"Calls form\",\n        description = \"Create call form\"\n)\npublic class CallsTest extends TestContext {\n    @DataProvider(name = \"callsData\")\n    public Object[][] getCallsData() {\n        return new Object[][]{\n                {\"Daily\", \"Daily conference\"},\n                {\"Weekly\", \"Weekly conference\"},\n                {\"Meeting John Doe\", \"Meeting with John Doe\"},\n                {\"Meeting Jane Doe\", \"Meeting with Jane Doe\"},\n        };\n    }\n\n    // ...\n}\n</code></pre> <p>Each test scenario that uses a Data Provider is executed once for each row of the data matrix. In our example, our data provider leifert a data matrix with four rows, accordingly the corresponding test scenarios are executed four times. The columns of the data matrix correspond to the number of parameters passed to the test scenarios. In our example, each execution of a test scenario would be passed two parameters of type String.</p> <p>Now we still need to link our test scenario to our data provider. First, add the attribute <code>dataProvider</code> to the <code>@Test</code> annotation and give this attribute the same value as the attribute <code>name</code> of the <code>@DataProvider</code> annotation. Furthermore, add two parameters of type String to your Java method. Within the test scenario, replace all static parameters with the new dynamic parameters that the method takes. This may look like this:</p> <p>Now you have successfully implemented a data-driven test case. Now run the test case as usual using the mvn clean test command.</p> <pre><code>@Test(testName = \"CallsTest\", description = \"Calls Test\", dataProvider = \"callsData\")\npublic void testCalls(String subject, String description) {\n    //Navigate to calls page\n    navigator.goToRootPage();\n    topNavbar.openMobileMenu();\n    topNavbar.clickMobileCallsMenu();\n    callsPage.clickCallsModuleButton();\n    topBarCallsMenu.clickLogCallLink();\n    // Fill call form\n    createCallForm.fillSubjectField(subject);\n    createCallForm.fillDurationField();\n    createCallForm.fillDescriptionField(description);\n    createCallPage.clickSaveButton();\n    //Navigate to Home page\n    topNavbar.openMobileMenu();\n    topNavbar.clickHomeMenuFromNotHomePage();\n}\n</code></pre> <p>You have now successfully implemented a data-driven test case. Now run the test case as usual using the <code>mvn clean test</code> command.</p>"},{"location":"sections/steps/Drivers/","title":"QTAF Drivers","text":"<p>This article explains how to use QTAF to test on different browsers easily and without changing your source code.</p>"},{"location":"sections/steps/Drivers/#what-are-drivers","title":"What are drivers?","text":"<p>A driver provides an interface between the test framework and the browser or the device with which a (web) application is to be tested. For example, if a web application is to be developed and it should run on the most common browsers, it is advisable to test the application automatically. This requires an interface between the test framework (for example Selenium) and the browser (Chrome, Firefox, Edge, Safari, ...). For each browser there is a driver that abstracts the details of how the browser is controlled and thus enables the tester to test his test cases with different browsers without changing his code.</p> <p>QTAF relieves the tester of the initialisation of a driver object. The tester only has to specify via the configuration file which browser he wants to use for testing.  To do this, he enters the name of the driver in the attribute <code>driver.name</code> of the configuration file. Alternatively, the environment variable <code>DRIVER_NAME</code> can be set or the parameter <code>-Ddriver.name</code> can be passed via the command line when executing the test cases.</p>"},{"location":"sections/steps/Drivers/#list-of-selenium-driver-configurations-provided-by-qtaf","title":"List of Selenium driver configurations provided by QTAF","text":"<p>The following is a list of Selenium drivers provided by the QTAF framework and the names you have to set for the parameter <code>driver.name</code> to use these.</p> Driver driver.name Description ChromeDriver chrome Driver for testing on a Chrome browser. ChromeRemoteDriver chrome-remote Driver for testing on a Chrome browser that is accessible via a network connection. EdgeDriver edge Driver for testing on an Edge browser. EdgeRemoteDriver edge-remote Driver for testing on an Edge browser that is accessible via a network connection. FirefoxDriver firefox Driver for testing on a Firefox browser. FirefoxRemoteDriver firefox-remote Driver for testing on a Firefox browser that is accessible via a network connection. OperaDriver opera Driver for testing on an Opera browser. OperaRemoteBrowser opera-remote Driver for testing on an Opera browser that is accessible via a network connection. InternetExplorerDriver ie Driver for testing on an Internet Explorer browser. SaucelabsDriver sauce Driver for testing on the Saucelabs platform"},{"location":"sections/steps/Drivers/#use-a-local-browser-for-testing","title":"Use a local browser for testing","text":"<p>QTAF uses the Webdrivermanager, so there is no need to install a Selenium driver on your PC. However, you must ensure that the desired browsers are installed on your PC. To test on a local browser, set the following configuration parameters:</p> Configuration parameter Value Description driver.name \u201cchrome\u201d | \u201cfirefox\u201d | \u201cedge\u201d | \u201copera\u201d | \u201cie\u201d Name of the drivers <p>This is already sufficient for QTAF to be able to execute the test cases on the desired browser. When executing the test cases, QTAF automatically starts the browser and executes the test cases in it.</p>"},{"location":"sections/steps/Drivers/#running-test-cases-on-a-remote-browser","title":"Running test cases on a remote browser","text":"<p>The Selenium driver and QTAF do not have to be on the same computer. It is also possible to connect QTAF to remote drivers via a network connection. Use cases for this include Docker environments or virtual machines running a Selenium driver. To do this, set the following configuration parameters:</p> Configuration parameter Value Description driver.name \u201cchrome-remote\u201d | \u201cfirefox-remote\u201d | \u201copera-remote\u201d Name of the browser / driver to be used driver.remoteUrl <code>&lt;remote url&gt;</code> URL under which the Selenium driver can be reached, e.g. 10.0.0.1:5555/wd/hub <p>For Docker, there are already pre-configured images that you can use out of the box. For example, you can create the following Docker Compose file and then connect to the Selenium containers.</p> <pre><code>version: '3'\nservices:\n  # Selenium chrome\n  selenium-chrome:\n    image: selenium/standalone-chrome-debug\n    ports:\n      - '4444:4444'\n    restart: always\n\n  # Selenium firefox\n  selenium-firefox:\n    image: selenium/standalone-firefox-debug\n    ports:\n      - '4445:4444'\n    restart: always\n\n  # Selenium opera\n  selenium-opera:\n    image: selenium/standalone-opera-debug\n    ports:\n      - '4446:4444'\n    restart: always\n</code></pre> <p>Assuming that the containers are running on your local machine, you need to set the following values for your configuration parameters:</p> Treiber driver.name driver.RemoteUrl Chrome chrome 127.0.0.1:4444/wd/hub Firefox firefox 127.0.0.1:4445/wd/hub Opera opera 127.0.0.1:4446/wd/hub"},{"location":"sections/steps/Drivers/#running-test-cases-on-the-saucelabs-platform","title":"Running test cases on the Saucelabs platform","text":"<p>QTAF can also run test cases on virtual machines provided by the Saucelabs platform. In order for QTAF to connect to Saucelabs virtual machines, the following configuration values must be set.</p> Configuration parameter Value Description driver.remoteUrl https://ondemand.eu-central-1.saucelabs.com/wd/hub URL under which the Selenium driver from Saucelabs can be reached. See also the following link. driver.name sauce driver.version <code>&lt;driver_version&gt;</code> version of the driver / browsers sauce.browserName <code>&lt;browser_name&gt;</code> Name of the browser (Chrome, Firefox, \u2026), see link driver.platform <code>&lt;platform_name&gt;</code> Name of the platform (Windows 10, Windows 11, \u2026), see link sauce.username <code>&lt;username&gt;</code> Saucelabs username (use environment variables for this configuration parameter for security reasons) sauce.accessKey <code>&lt;access_key&gt;</code> Saucelabs access key (use environment variables for this configuration parameter for security reasons)"},{"location":"sections/steps/Drivers/#writing-your-own-drivers","title":"Writing your own drivers","text":"<p>In some scenarios, QTAF's pre-configured drivers may not meet the tester's needs. In this case, QTAF offers the possibility to write your own driver class and use it during testing. </p> <p>Let us assume for the following scenario that you want to test on a browser for which QTAF does not provide a corresponding driver. However, you have found a library that provides such a Selenium-compatible driver and now want to use this driver with QTAF. Proceed as follows:</p> <p>Create a package in your Java project in which you want to write the driver class. In this example, this is the package <code>org.acme.driver</code>.</p> <p>In this package, create a class that implements the class <code>de.qytera.qtaf.core.driver.AbstractDriver</code>. In our example, this class is called <code>MyDriver</code>. Now you have to implement the following methods: <code>getName</code> and <code>getDriver</code>. The method <code>getName</code> returns the name of the browser to be used in the configuration file. The <code>getDriver</code> method returns a driver object that implements the <code>WebDriver</code> interface of the Selenium framework.</p> <pre><code>package org.acme;\n\nimport de.qytera.qtaf.core.driver.AbstractDriver;\nimport org.openqa.selenium.WebDriver;\n\npublic class MyDriver extends AbstractDriver {\n    @Override\n    public String getName() {\n        return \"my-driver\"; // Replace this with your own name\n    }\n\n    @Override\n    public WebDriver getDriver() {\n        return new SampleDriver(); // Replace this with your own driver implementation\n    }\n}\n</code></pre> <p>In order for QTAF to be able to find your implementation of the driver, you must also enter the name of the package in which the driver is to be found in the configuration file. You can also enter several packages here. QTAF will scan this package for all classes that implement the <code>AbstractDriver</code> interface.</p> <pre><code>{\n  \"framework\": {\n    \"packageNames\": [\n      \"org.acme.driver\"\n    ]\n  }\n}\n</code></pre> <p>Now you have to enter the name of your driver in the configuration file.</p> <pre><code>{\n  \"driver\": {\n    \"name\": \"my-driver\"\n  }\n}\n</code></pre> <p>Now you can run your tests with the new driver.</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/steps/HTML_Report_Plugin/","title":"The HTML Report Plugin","text":"<p>The QTAF HTML report plugin offers the possibility to create an HTML report from the log messages generated by QTAF, which can then be opened in a browser.</p> <p>The HTML report plugin is included in the QTAF framework by default. You do not need to add any dependencies other than the QTAF framework itself in your <code>pom.xml</code> file.</p> <p>You can view an example of an HTML report from QTAF here: QTAF HTML Report</p>"},{"location":"sections/steps/HTML_Report_Plugin/#activating-the-html-report-plugin","title":"Activating the HTML Report Plugin","text":"<p>In addition to <code>qtaf-core</code>, first integrate the dependency <code>qtaf-html-report-plugin</code> into your project: Make sure that you use the current version numbers of these modules. You can find them at the Maven Repository</p> <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n        &lt;artifactId&gt;qtaf-core&lt;/artifactId&gt;\n        &lt;version&gt;0.0.3&lt;/version&gt;\n        &lt;scope&gt;compile&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n        &lt;artifactId&gt;qtaf-html-report-plugin&lt;/artifactId&gt;\n        &lt;version&gt;0.0.3&lt;/version&gt;\n        &lt;scope&gt;compile&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>To activate the HTML-Report-Plugin you have to set the value <code>htmlReport.enabled</code> in the configuration file to true. Then run your test cases.</p> <pre><code>{\n  \"htmlReport\": {\n    \"enabled\": true\n  }\n}\n</code></pre>"},{"location":"sections/steps/HTML_Report_Plugin/#displaying-the-html-reports","title":"Displaying the HTML reports","text":"<p>You will find the HTML reports in the folder <code>./logs</code> relative to the root directory of your project. The generated HTML files can be opened in any browser. Let's now take a look at the structure of the report.</p> <p>First, the report shows you general information about the execution of the test cases, such as the execution time of the test suite, start and end dates, and the Selenium driver used.</p> <p></p> <p>Below this information you will find a list of the test features that the executed test suite contains. In this example, these are the test features <code>QTAF-496</code> and <code>QTAF-567</code>. The names of the test features come from the annotation <code>@TestFeature</code> of the respective Java classes that represent the respective test features.</p> <pre><code>@TestFeature(\n        name = \"QTAF-496\",\n        description = \"Login to the CRM\"\n)\n@Singleton\npublic class LoginFeature extends TestContext {\n    @Test(\n        testName = \"QTAF-496\",\n        description = \"Login Test\"\n    )\n    public void testLogin(){\n        navigator.goToRootPage();\n        loginForm.fillUsernameField(\"user\");\n        // ...\n    }\n}\n</code></pre> <p></p> <p>Below the respective test features you can see a list of the test scenarios that contain the test features. Test scenarios are represented in TestNG by the methods of a test class, which are provided with the annotation <code>@Test</code>. The name of the scenarios displayed in the HTML report comes from the attribute <code>name</code> of this annotation.</p> <p>If we now click on the button to the right of the scenario name, we get more details about the executed test scenario. On the one hand, we see the full path of the class and the method it contains, which represents the scenario shown. In this example, this would be the class <code>de.qytera.suite_crm.Logintest.testLogin</code>. This ensures the traceability of the test results to the test definitions. Further information displayed in the report are the start and end times of the execution of the test scenario as well as its duration.</p> <p></p> <p>But the report contains even more information about the executed test cases. Now click on the button to the right of \"Steps\" to get information about the individual test steps of the scenario.</p> <p>You will now see a list of the test steps of the test scenario. Each test step listed in the report corresponds to the call of a Java method annotated with the annotation <code>@Step</code>. In our example, these are the methods <code>goToRootPage</code> and <code>fillUsernameField</code>. These come respectively from the two page object classes <code>Navigator</code> and <code>LoginFormPO</code>. These page object classes could look like this:</p> <pre><code>@Singleton\npublic class Navigator extends SuiteCRMTestContext {\n    @Step(\n            name = \"Go to SuiteCRM main page\",\n            description = \"Navigate to the SuiteCRM main home page\"\n    )\n    public void goToRootPage() {\n        String url = \"http://127.0.0.1:80\";\n        driver.get(url);\n    }\n}\n</code></pre> <pre><code>@Singleton\npublic class LoginFormPO extends SuiteCRMTestContext {\n    protected String usernameFieldId = \"user_name\";\n    // ...\n\n    @Step(name = \"Fill username field\", description = \"Fill the username field\")\n    public void fillUsernameField(String username) {\n        driver.findElement(By.id(usernameFieldId)).sendKeys(username);\n    }\n\n    // ...\n}\n</code></pre> <p>In the HTML report, you can see that the individual steps contain information about the complete package path of these methods. Thus, traceability between test steps and test documentation is also guaranteed for the test steps.</p> <p>Furthermore, you can also see that the passed parameters of the test steps are documented. For example, a parameter of the type string with the value <code>\"user\"</code> was passed to the method <code>fillUsernameField</code>.</p> <p></p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/steps/New_QTAF_Project/","title":"How to create a new QTAF project","text":"<p>This article shows how a new project can be set up using the QTAF framework. First, we will show you how to install QTAF using Maven. Then we will create our first test case using QTAF.</p>"},{"location":"sections/steps/New_QTAF_Project/#set-up-a-new-project-with-intellij","title":"Set up a new project with IntelliJ","text":""},{"location":"sections/steps/New_QTAF_Project/#create-new-project","title":"Create new Project","text":"<p>To create a new project, we use the IntelliJ IDE from Jetbrains. Here we navigate in the menu to <code>File &gt; New &gt; Project</code> and then select <code>Maven</code> in the left selection menu and click on <code>Next</code>.</p> <p>Chose a name for the project. The name can be chosen freely, but in this example we use the name \"QtafProject\". It is recommended to also specify the GroupId of the project. This is an identifier for the creator of the project. It is common to choose the company's domain for this, but starting with the country- or organisation-specific ending of the domain. For a company domain \"acme.org\", one would choose the GroupId \"org.acme\" according to this standard. The GroupId can be found in the sub-item Artifact Coordinates. Then we click on Finish. The new project should now have been created in the folder <code>~\\IdeaProjects\\QtafProject</code>, where <code>~</code> is a placeholder for the root directory of the currently logged in user.</p>"},{"location":"sections/steps/New_QTAF_Project/#customise-pom-to-add-qtaf-to-the-project","title":"Customise Pom to add QTAF to the project","text":"<p>After creating the project, a file called <code>pom.xml</code> should have been created  in the root directory of the project.  This file is used to configure Maven projects, i.e. to load external libraries, to control the build process, etc. The file should have a similar content as the example below:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;org.acme&lt;/groupId&gt;\n    &lt;artifactId&gt;QtafProject&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/project&gt;\n</code></pre> <p>This file can be used to manage plug-ins and extensions of the project. </p>"},{"location":"sections/steps/New_QTAF_Project/#add-the-qtaf-dependency","title":"Add the QTAF dependency","text":"<p>To set up QTAF you only have to include QTAF as a dependency in the project.  To do this, add the following code to pom.xml:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n    &lt;artifactId&gt;qtaf-core&lt;/artifactId&gt;\n    &lt;version&gt;${qtafVersion}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"sections/steps/New_QTAF_Project/#add-the-current-version","title":"Add the current version","text":"<p>Replace <code>${qtafVersion}</code> by the version number with the latest version of QTAF. You can find the available versions in the Central Maven Repository under the following link: QTAF Central Repository</p>"},{"location":"sections/steps/New_QTAF_Project/#where-to-place-your-dependencies","title":"Where to place your dependencies","text":"<p>All individual dependencies are inserted between an opening and a closing dependencies tag. If the <code>&lt;dependencies&gt;  &lt;!dependencies&gt;</code> tag is not yet available, you can create it manually. The structure would look something like this</p> <p><pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;!--dependency 1 --&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;!--dependency 2 --&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;!--dependency 3 --&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> If you have a project where you just want to add QTAF as a dependency,  it would look like this:</p> <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n        &lt;artifactId&gt;qtaf-core&lt;/artifactId&gt;\n        &lt;version&gt;${qtafVersion}&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"sections/steps/New_QTAF_Project/#refresh-the-project","title":"Refresh the project","text":"<p>Every time the pom.xml file is changed,  the project must be reloaded manually to implement the changes. In intellij, a button to reload the dependencies is displayed in the upper right corner, if this might be necessary. The shortcut for Windows is <code>CTR + Shift + O</code>.</p>"},{"location":"sections/steps/New_QTAF_Project/#check-qtaf-installation","title":"Check QTAF installation","text":"<p>The appropriate dependencies should now have been installed  under External Libraries.  This includes QTAF.  To check this, search in External Libraries for libaries  that start as follows <code>de.qytera:qtaf...</code></p>"},{"location":"sections/steps/New_QTAF_Project/#create-first-test-case-and-test-class","title":"Create first test case and test class","text":"<p>Now the project should be initialised. We can now devote ourselves to creating the first test case.</p> <p>First we create the package <code>org.acme.tests</code> in the directrory <code>src/test/java</code>, where we will store our test case classes in the future. Create a class <code>TestOne</code> in this package with the following content:</p> <pre><code>package org.acme.tests;\n\nimport de.qytera.qtaf.core.config.annotations.TestFeature;\nimport de.qytera.qtaf.testng.context.QtafTestNGContext;\nimport org.testng.annotations.Test;\n\n@TestFeature(\n        name = \"TestCase One\",\n        description = \"First test\"\n)\npublic class TestOne extends QtafTestNGContext {\n\n    @Test(testName = \"Test Success\", description = \"This test should pass\")\n    public void testSuccess() {\n        assertEquals(2 * 2, 4);\n    }\n\n    @Test(testName = \"Test Failure\", description = \"This test should fail\")\n    public void testFailure() {\n        assertEquals(2 * 2, 3);\n    }\n}\n</code></pre>"},{"location":"sections/steps/New_QTAF_Project/#run-tests","title":"Run tests","text":"<p>You can run the tests in two ways. In the first case, you can run the tests via the command line with the command <code>mvn clean test</code>. In our example, one test should succeed and the second test should fail. The output on the command line should end with the following text:</p> <pre><code>Results :\n\nFailed tests:   testFailure(org.acme.tests.TestOne): expected [3] but found [4]\n\nTests run: 2, Failures: 1, Errors: 0, Skipped: 0\n\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  15.570 s\n[INFO] Finished at: 2023-01-01T11:04:36+01:00\n[INFO] ------------------------------------------------------------------------\n</code></pre> <p>The second option is to run tests using the IntelliJ IDE. To do this, click on the green triangles next to the test methods in the <code>TestOne</code> class to run individual tests or on the green triangle next to the <code>TestOne</code> class itself and then click on Run test in the menu that opens to run all tests.</p> <p>You will now see the following things: New directories and files have been created in your project. A new file named <code>qtaf.json</code> has been created in the resource directory. Within this file you can define parameters for the test execution.</p> <p>A new directory called <code>logs</code> has also been created. In this directory, you can now observe that for each test run, a subdirectory is created that contains information about the test run.</p>"},{"location":"sections/steps/New_QTAF_Project/#create-a-selenium-test-case","title":"Create a Selenium test case","text":"<p>QTAF has been developed with a particular focus on web application testing and therefore offers special support for Selenium test cases. The Selenium library has already been installed by including QTAF as a dependency in your Maven project. To create a new Selenium test case, we proceed as in the example shown earlier. First we create a test class called <code>SeleniumTest</code> and let this class inherit from <code>QtafTestNGContext</code>. Now we again create a method within this class and provide it again with the annotation <code>@Test</code>from TestNG.</p> <p>The class <code>QtafTestNGContext</code> provides us with the <code>driver</code> object, with which we can control our browser. The <code>driver</code>object is an ordinary Selenium web driver object, which we can work with as usual from other Selenium projects. The documentation of the Selenium driver for Java including a small example can be found on the following website: Selenium Documentation</p> <p>We would now like to look at how we would write the test case described in the Selenium documentation using QTAF. The Selenium test case without QTAF looks like this:</p> <pre><code>import org.testng.Assert;\nimport org.testng.annotations.Test;\n\npublic class HelloSeleniumTest {\n    By headlineSelector = By.cssSelector(\"h1.d-1\");\n\n    @Test(\n      testName = \"Open browser and visit selenium documentation\",\n      description = \"Open the browser and go to the selenium documentation website\"\n    )\n    public void testBrowser() {\n        // Instatiate WebDriver object\n        WebDriver driver = new ChromeDriver();\n\n        // Visit Selenium documentation\n        driver.get(\"https://selenium.dev\");\n\n        // Extract headline text from website\n        String headlineText = driver.findElement(headlineSelector).getText();\n        Assert.assertEquals(headlineText, \"Selenium automates browsers. That's it!\");\n\n        // Close the driver\n        driver.quit();\n    }\n}\n</code></pre> <p>If we now use QTAF, our test case looks like this:</p> <pre><code>import de.qytera.qtaf.core.config.annotations.TestFeature;\nimport de.qytera.qtaf.testng.context.QtafTestNGContext;\nimport org.testng.Assert;\nimport org.testng.annotations.Test;\n\n@TestFeature(\n        name = \"SeleniumTest\",\n        description = \"Our first Selenium test\"\n)\npublic class HelloSeleniumTest extends QtafTestNGContext {\n    By headlineSelector = By.cssSelector(\"h1.d-1\");\n\n    @Test(\n      testName = \"Open browser and visit selenium documentation\",\n      description = \"Open the browser and go to the selenium documentation website\"\n    )\n    public void testBrowser() {\n        // Visit Selenium documentation\n        driver.get(\"https://selenium.dev\");\n\n        // Extract headline text from website\n        // assertEquals($(headlineSelector).text(), \"Selenium automates browsers. That's it!\");\n        assertEquals(driver.findElement(headlineSelector).getText(), \"Selenium automates browsers. That's it!\");\n    }\n}\n</code></pre> <p>We only need to do two things to convert an ordinary TestNG test case into a QTAF test case:</p> <ol> <li>The class must be annotated with the <code>TestFeature</code> annotation, which is provided by the QTAF library.</li> <li>Our class must inherit from <code>QtafTestNGContext</code>.</li> </ol> <p>If we look at the code inside the method we notice two more things: The statements for instantiating and closing the webdriver have been removed. QTAF takes over these tasks for us and already provides us with the initialised driver object via the class attribute <code>driver</code>.</p> <p>A QTAF test case is thus an ordinary TestNG test case that we have merely extended with an annotation and an inherited class. Thus, every TestNG test case can also be converted into a QTAF test case.</p>"},{"location":"sections/steps/New_QTAF_Project/#divide-test-cases-into-test-steps-and-page-objects","title":"Divide test cases into test steps and page objects","text":"<p>Now that we have created our first test case we can move on to restructuring our test case. In our test case we have carried out two main steps: First, we called the desired page in the browser and then we extracted the text of a web element from the page using a selector. Then we checked whether this text corresponds to the text we wanted. Some of these test steps might also be of interest in other test cases, especially calling the website using <code>driver.get()</code> might occur more often in our test cases. Therefore, it makes sense to outsource these test steps to their own methods. First, we could create three methods within the test class into which we outsource the code of the respective test steps. In the test case, only these methods are called. Especially if the test steps become more complex in the course of a test project, it makes sense to split the code into methods. In our example, these test methods could look like this:</p> <pre><code>package org.acme.tests;\n\nimport de.qytera.qtaf.core.config.annotations.TestFeature;\nimport de.qytera.qtaf.testng.context.QtafTestNGContext;\nimport org.testng.Assert;\nimport org.testng.annotations.Test;\n\n@TestFeature(\n        name = \"SeleniumTest\",\n        description = \"Our first Selenium test\"\n)\npublic class HelloSeleniumTest extends QtafTestNGContext {\n    By headlineSelector = By.cssSelector(\"h1.display-1\");\n\n    @Test(\n        testName = \"Open browser and visit selenium documentation\",\n        description = \"Open the browser and go to the selenium documentation website\"\n    )\n    public void testBrowser() {\n        openSite(\"https://selenium.dev\");\n        checkHeadline(\"Selenium automates browsers. That's it!\");\n    }\n\n    public void openSite(String url) {\n        // Visit Selenium documentation\n        driver.get(url);\n    }\n\n    public void checkHeadline(String expectedText) {\n        // Extract headline text from website\n        assertEquals($(headlineSelector).text(), expectedText);\n    }\n}\n</code></pre> <p>The advantages of this code example are obvious: the code becomes more readable and by outsourcing test steps to separate methods,  they can also be reused in other test cases. However, QTAF goes one step further and expects methods that represent test steps to  be defined in separate classes.  Thus, there are classes in which the methods contain test cases and other classes in which the methods only contain test steps.  Instead of defining all test steps within a single class, it makes sense to bundle only those test steps within a class  that all address a specific area of the website. Areas of the website can be, for example,  a login form, a navigation bar or a specific menu. This also contributes to the maintainability of the code in larger projects.</p>"},{"location":"sections/steps/New_QTAF_Project/#page-objects","title":"Page Objects","text":"<p>Let's now look at how to define such a page object class in QTAF. We first create the package <code>org.acme.page_objects</code>,  in which we will define our page object classes. The name of the package can also be chosen differently.  In this package we now create the class <code>MainSitePO</code> that extends <code>QtafTestNGContext</code>. Within this class we define the methods <code>openSite</code> and <code>checkHeadline</code>  as we had defined them before in the class <code>HelloSeleniumTest</code>. </p>"},{"location":"sections/steps/New_QTAF_Project/#step-annotations","title":"Step Annotations","text":"<p>Then we have to add annotations to our new class.  We add the annotation <code>@Step</code> to each method that represents a test step.  Within this annotation we can define the attributes name and description.  The name and description of the test step will be used later in the reporting.</p> <p>Our new page object class should look like this:</p> <pre><code>package org.acme.page_objects;\n\nimport de.qytera.qtaf.core.guice.annotations.Step;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebElement;\n\nimport javax.inject.Singleton;\n\n\npublic class MainSitePO extends QtafTestNGContext {\n    By headlineSelector = By.cssSelector(\"h1.display-1\");\n\n    @Step(\n        name = \"Open Site\",\n        description = \"Open the selenium documentation website in the browser\"\n    )\n    public void openSite(String url) {\n        // Visit Selenium documentation\n        driver.get(url);\n    }\n\n    @Step(\n        name = \"Check Headline\",\n        description = \"Check if the headline of the site cintains a specific text\"\n    )\n    public void checkHeadline(String expectedText) {\n        // Extract headline text from website\n        assertEquals($(headlineSelector).text(), expectedText);\n    }\n}\n</code></pre> <p>Now we need to instantiate this page object class in out test case. This can be done by the function <code>load</code> that is provided by the QTAF test context. This function accepts a class reference and creates a new instance of this class. It is important to instantiate the page object by calling the <code>load</code>and not using the <code>new</code>keyword, otherwise logging will not work for this page object. Internally QTAF injects code before and after each step method so that we can trace these functions. Our test case class, which now uses our page object class, then looks like this:</p> <pre><code>package org.acme.tests;\n\nimport de.qytera.qtaf.core.config.annotations.TestFeature;\nimport de.qytera.qtaf.testng.context.QtafTestNGContext;\nimport org.testng.annotations.Test;\n\n@TestFeature(\n        name = \"SeleniumTest\",\n        description = \"Our first Selenium test\"\n)\npublic class HelloSeleniumTest extends QtafTestNGContext {\n    @Test(\n        testName = \"Open browser and visit selenium documentation\",\n        description = \"Open the browser and go to the selenium documentation website\"\n    )\n    public void testBrowser() {\n        // Instantiate page objects\n        MainSitePO mainSitePO = load(MainSitePO.class)\n\n        // Test case\n        mainSitePO.openSite(\"https://selenium.dev\");\n        mainSitePO.checkHeadline(\"Selenium automates browsers. That's it!\");\n    }\n}\n</code></pre> <p>Now we have divided our project into page objects and the test steps defined in them. We can now call the main method of <code>TestRunner</code> or execute the command <code>mvn clean test</code>. This will run our test cases.</p>"},{"location":"sections/steps/New_QTAF_Project/#create-reports","title":"Create reports","text":"<p>QTAF offers you the possibility to automatically create reports from your test runs. In this example we show you two reporting formats integrated into the QTAF framework, one documenting the test execution by means of a JSON document and the other one creating an HTML report. The JSON document is interesting for the machine processing of the test results, the HTML report for the testers as a graphical presentation of the test results.</p>"},{"location":"sections/steps/New_QTAF_Project/#add-qtaf-html-report-plugin","title":"Add QTAF HTML Report plugin","text":"<p>First, we need to add the QTAF HTML Report plugin as a dependency to our project. To do this, add the following dependency to the pom.xml file.</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n    &lt;artifactId&gt;qtaf-html-report-plugin&lt;/artifactId&gt;\n    &lt;version&gt;${qtafVersion}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Since the pom.xml has been changed, you should not forget to reload the dependencies.</p>"},{"location":"sections/steps/New_QTAF_Project/#activate-html-report","title":"Activate HTML report","text":"<p>Furthermore, we have to activate the creation of the HTML report in the <code>qtaf.json</code> file. The <code>qtaf.json</code> file can be found under <code>src/test/resources</code> in the project folder. Make sure that the value <code>htmlReport.enabled</code> in the configuration file is set to <code>true</code>:</p> <pre><code>  \"htmlReport\":{\n    \"enabled\":true\n  }\n</code></pre> <p>Then run the test cases again by executing the main method of the <code>TestRunner</code> class. You will then find the file <code>Report.html</code> in the logs directory, which contains the HTML report. You can open and display this in any browser.</p> <p>In the same directory you will find the file <code>Report.json</code>, which contains the data of the test run as a JSON document.</p> <p>You can find an example of an HTML report here: QTAF HTML Report</p> <p>You can also find an example JSON report here: QTAF JSON Report</p>"},{"location":"sections/steps/New_QTAF_Project/#run-test-cases-on-different-browsers","title":"Run test cases on different browsers","text":"<p>QTAF offers you the possibility to run test cases on different browsers. You can tell QTAF in three different ways which browser it should use to run the test cases. The only requirement is that the browsers themselves have already been installed by you on your computer. QTAF will automatically download the appropriate Selenium drivers for the desired browsers. You therefore do not need to worry about setting up the appropriate drivers.</p> <p>Option 1: Use the configuration file</p> <p>Change the value of the <code>driver.name</code> attribute in the <code>qtaf.json</code> file. Possible values include <code>chrome</code>, <code>firefox</code>, <code>edge</code>, <code>opera</code> and <code>ie</code>.</p> <pre><code>  \"driver\":{\n    \"name\": \"chrome\"\n  }\n</code></pre> <p>Then run your test cases as usual. For example, if you have selected <code>firefox</code> as the value, the test cases will now be executed in the Firefox browser.</p> <p>Option 2: Use the command line</p> <p>QTAF test cases can also be executed via the command line. This is advantageous if you want to run test cases in a pipeline on different browsers, as in this case you do not have to make any changes to the code base. To run test cases from the command line you have to execute the command <code>mvn clean test</code>. Please note that the package name <code>org.acme</code> may differ from project to project. You can also pass the desired browser using the argument <code>-Ddriver.name</code>. For the Firefox browser, the command would look like this: <code>mvn clean test -Ddriver.name=\"firefox\"</code>. Command line arguments always overwrite the values in the configuration file, i.e. if you have set the value <code>chrome</code> for <code>driver.name</code> in the configuration file, but pass the value <code>firefox</code> via the command line, your test cases will ultimately be executed in the Firefox browser.</p> <p>Option 3: Use environment variables</p> <p>As a third option, QTAF offers to set configuration parameters via environment variables. For example, if you want to test on the Edge browser, set the environment variable <code>DRIVER_NAME</code> to the value <code>edge</code>. In a Bash shell, you can also set environment variables directly before the actual command. This would look like this: <code>DRIVER_NAME=edge mvn clean test</code>. Environment variables also always overwrite the values in the <code>qtaf.json</code> file.</p> Developed with love by Qytera, Germany | Support &amp; Service | QTAF Repository | Contact"},{"location":"sections/steps/QTAF_Groovy/","title":"Use QTAF with Groovy","text":"<p>QTAF is written in Java, but can also be used with Groovy, as Java and Groovy compile to Bytecode for the same runtime. For creating a new QTAF project with Groovy you can choose between Maven and Gradle as a build system. In this article we will show you for both systems how you can setup a new QTAF project.</p>"},{"location":"sections/steps/QTAF_Groovy/#new-qtaf-groovy-project-using-maven","title":"New QTAF Groovy project using Maven","text":"<p>Create a new project with IntelliJ or VSCode as you would create it when using Java. The <code>pom.xml</code> file should look like the following code sample.</p> <p>There are two dependencies you have to add to <code>pom.xml</code>: - groovy-all - qtaf-core</p> <p>Also you need to add the following Maven plugins: - GMavenPlus Plugin</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;de.qytera.qtafgroovy&lt;/groupId&gt;\n    &lt;artifactId&gt;QtafGroovyMavenDemo&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.groovy&lt;/groupId&gt;\n            &lt;artifactId&gt;groovy-all&lt;/artifactId&gt;\n            &lt;version&gt;4.0.2&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n            &lt;artifactId&gt;qtaf-core&lt;/artifactId&gt;\n            &lt;version&gt;0.2.0&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.codehaus.gmavenplus&lt;/groupId&gt;\n                &lt;artifactId&gt;gmavenplus-plugin&lt;/artifactId&gt;\n                &lt;version&gt;1.13.1&lt;/version&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;execute&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n                &lt;dependencies&gt;\n                    &lt;dependency&gt;\n                        &lt;groupId&gt;org.apache.groovy&lt;/groupId&gt;\n                        &lt;artifactId&gt;groovy&lt;/artifactId&gt;\n                        &lt;version&gt;4.0.2&lt;/version&gt;\n                        &lt;scope&gt;runtime&lt;/scope&gt;\n                    &lt;/dependency&gt;\n                &lt;/dependencies&gt;\n                &lt;configuration&gt;\n                    &lt;scripts&gt;\n                        &lt;script&gt;src/main/groovy/Main.groovy&lt;/script&gt;\n                    &lt;/scripts&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n\n&lt;/project&gt;\n</code></pre>"},{"location":"sections/steps/QTAF_Groovy/#new-qtaf-groovy-project-using-gradle","title":"New QTAF Groovy project using Gradle","text":"<p>If you use Gradle the file <code>build.gradle</code> should have the following content:</p> <pre><code>plugins {\n    id 'groovy'\n}\n\ngroup = 'de.qytera.qtaf'\nversion = '1.0-SNAPSHOT'\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.apache.groovy:groovy:4.0.2'\n    implementation 'de.qytera:qtaf-core:0.2.0'\n}\n\ntest {\n    useTestNG() { //Tells Gradle to use TestNG\n        useDefaultListeners = true // Tells TestNG to execute its default reporting structure\n        suites 'src/test/suite.xml' //location of our suite.xml\n    }\n}\n</code></pre>"},{"location":"sections/steps/QTAF_Groovy/#creating-page-object-classes","title":"Creating page object classes","text":"<p>A page object class in Groovy looks like the following code snippet. Methods and classes MUST not be defined using the keyword <code>def</code>, otherwise logging will not work correctly.</p> <pre><code>// src/test/&lt;your-package-name&gt;/SeleniumPage.groovy\nimport de.qytera.qtaf.core.guice.annotations.Step\nimport de.qytera.qtaf.testng.context.QtafTestNGContext\n\nimport static com.codeborne.selenide.Selenide.$\n\nclass SeleniumPage extends QtafTestNGContext {\n    @Step(name = \"Open site\", description = \"Open the website https://www.selenium.dev\")\n    void openSite() {\n        driver.get(\"https://www.selenium.dev\")\n    }\n\n    @Step(name = \"Check headline\", description = \"Check that the headline matches the given text\")\n    void checkHeadline(String expectedText) {\n        assertEquals($(\"h1\").text(), expectedText)\n    }\n}\n</code></pre> <p>A test case in Groovy looks like the following sample. Also make surenot to use the keyword <code>def</code> for methods.</p>"},{"location":"sections/steps/QTAF_Groovy/#create-test-case-classes","title":"Create test case classes","text":"<pre><code>// src/test/&lt;your-package-name&gt;/DemoTest.kt\nimport de.qytera.qtaf.core.config.annotations.TestFeature\nimport de.qytera.qtafgroovy.page_objects.SeleniumPage\nimport de.qytera.qtaf.testng.context.QtafTestNGContext\nimport org.testng.annotations.Test\n\n@TestFeature(name = \"Test Feature One\", description = \"Test Feature One\")\nclass TestOne extends QtafTestNGContext {\n    @Test(testName = \"Test One\", description = \"Test One\")\n    void testOne() {\n        def page = load(SeleniumPage)\n        page.openSite()\n        page.checkHeadline(\"Selenium automates browsers. That's it!\")\n    }\n}\n</code></pre>"},{"location":"sections/steps/QTAF_Groovy/#running-the-test-cases","title":"Running the test cases","text":"<p>You can run the test cases with the same command as in Java: <code>mvn clean test</code> or <code>gradle test</code>.</p> <p>The second option is to create a class that extends <code>TestRunner</code> and call its <code>main</code> method. Here is the code for this class:</p> <pre><code>// src/test/&lt;your-package-name&gt;/Main.kt\nclass TestRunner extends QtafTestNGRunner {\n}\n</code></pre>"},{"location":"sections/steps/QTAF_Kotlin/","title":"Use QTAF with Kotlin","text":"<p>QTAF is written in Java, but can also be used with Kotlin, as Java and Kotlin compile to Bytecode for the same runtime. For creating a new QTAF project with Kotlin you can choose between Maven and Gradle as a build system. In this article we will show you for both systems how you can setup a new QTAF project.</p>"},{"location":"sections/steps/QTAF_Kotlin/#new-qtaf-kotlin-project-using-maven","title":"New QTAF Kotlin project using Maven","text":"<p>Create a new project with IntelliJ or VSCode as you would create it when using Java. The <code>pom.xml</code> file should look like the following code sample.</p> <p>There are two dependencies you have to add to <code>pom.xml</code>: - kotlin-stdlib - qtaf-core</p> <p>Also you need to add the following Maven plugins: - Kotlin Maven Plugin - Exec Maven Plugin - Apache maven Compiler Plugin</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;artifactId&gt;KotlinQtafMavenDemo&lt;/artifactId&gt;\n    &lt;groupId&gt;org.example&lt;/groupId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;consoleApp&lt;/name&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;kotlin.code.style&gt;official&lt;/kotlin.code.style&gt;\n        &lt;kotlin.compiler.jvmTarget&gt;17&lt;/kotlin.compiler.jvmTarget&gt;\n    &lt;/properties&gt;\n\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;mavenCentral&lt;/id&gt;\n            &lt;url&gt;https://repo1.maven.org/maven2/&lt;/url&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n\n    &lt;build&gt;\n        &lt;sourceDirectory&gt;src/main/kotlin&lt;/sourceDirectory&gt;\n        &lt;testSourceDirectory&gt;src/test/kotlin&lt;/testSourceDirectory&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;\n                &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;1.9.0&lt;/version&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;compile&lt;/id&gt;\n                        &lt;phase&gt;compile&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;compile&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;test-compile&lt;/id&gt;\n                        &lt;phase&gt;test-compile&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;test-compile&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;\n                &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;1.6.0&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;mainClass&gt;MainKt&lt;/mainClass&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;17&lt;/source&gt;\n                    &lt;target&gt;17&lt;/target&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;\n            &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;\n            &lt;version&gt;1.9.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;de.qytera&lt;/groupId&gt;\n            &lt;artifactId&gt;qtaf-core&lt;/artifactId&gt;\n            &lt;version&gt;0.2.0&lt;/version&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"sections/steps/QTAF_Kotlin/#new-qtaf-kotlin-project-using-gradle","title":"New QTAF Kotlin project using Gradle","text":"<p>If you use Gradle the file <code>build.gradle.kts</code> should have the following content:</p> <pre><code>plugins {\n    kotlin(\"jvm\") version \"1.8.0\"\n    application\n}\n\ngroup = \"de.qytera\"\nversion = \"0.0.1\"\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    testImplementation(kotlin(\"test\"))\n    implementation(\"de.qytera:qtaf-core:0.2.0\")\n}\n\ntasks.test {\n    useTestNG() { //Tells Gradle to use TestNG\n        useDefaultListeners = true // Tells TestNG to execute its default reporting structure\n        suites(\"testng.xml\")\n    }\n}\n\nkotlin {\n    jvmToolchain(17)\n}\n\napplication {\n    mainClass.set(\"TestRunnerKt\")\n}\n</code></pre>"},{"location":"sections/steps/QTAF_Kotlin/#creating-page-object-classes","title":"Creating page object classes","text":"<p>A page object class in Kotlin looks like the following code snippet. Methods and classes MUST be marked with the keyword <code>open</code>, otherwise logging will not work correctly, because internally these classes and methods are compile to final classes and final method. These methods cannot be intercepted by the framework we use for tracking calls to these methods.</p> <pre><code>// src/test/&lt;your-package-name&gt;/SeleniumPage.kt\nimport com.codeborne.selenide.Selenide.element\nimport de.qytera.qtaf.core.guice.annotations.Step\nimport de.qytera.qtaf.testng.context.QtafTestNGContext\nimport org.openqa.selenium.By\n\n\nopen class SeleniumPage : QtafTestNGContext() {\n    private val headlineSelector: By = By.cssSelector(\"h1\")\n\n    @Step(name = \"Open Website\", description = \"Navigate to the given URL\")\n    open fun openWebsite(url: String) {\n        driver.get(url)\n    }\n\n    @Step(name = \"Read headline\", description = \"Read the headline of the website\")\n    open fun checkHeadline(expectedText: String) {\n        val givenText = element(headlineSelector).text()\n        assertEquals(givenText, expectedText, \"Expected headline to be $expectedText, but was $givenText\")\n    }\n}\n</code></pre> <p>A test case in Kotlin looks like the following sample. Also make sure that your classes and methods are marked as <code>open</code>.</p>"},{"location":"sections/steps/QTAF_Kotlin/#create-test-case-classes","title":"Create test case classes","text":"<pre><code>// src/test/&lt;your-package-name&gt;/DemoTest.kt\nimport de.qytera.kotlindemo.page_objects.SeleniumPage\nimport de.qytera.qtaf.core.config.annotations.TestFeature\nimport de.qytera.qtaf.testng.context.QtafTestNGContext\nimport org.testng.annotations.Test\n\n@TestFeature(name = \"Test One\", description = \"Test One\")\nopen class DemoTest() : QtafTestNGContext() {\n    @Test()\n    open fun testOne() {\n        val page: SeleniumPage = load(SeleniumPage::class.java)\n        page.openWebsite(\"https://www.selenium.dev\")\n        page.checkHeadline(\"Selenium automates browsers. That's it!\")\n    }\n}\n</code></pre>"},{"location":"sections/steps/QTAF_Kotlin/#running-the-test-cases","title":"Running the test cases","text":"<p>You can run the test cases with the same command as in Java: <code>mvn clean test</code> or <code>gradle test</code>.</p> <p>The second option is to create a class that extends <code>TestRunner</code> and call its <code>main</code> method. Here is the code for this class:</p> <pre><code>// src/test/&lt;your-package-name&gt;/TestRunner.kt\nimport de.qytera.qtaf.testng.QtafTestNGRunner\n\nfun main(args: Array&lt;String&gt;) {\n    QtafTestNGRunner.main(args)\n}\n</code></pre>"}]}